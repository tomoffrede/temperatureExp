---
title: "Analysis - Speech - All models"
author: "Tom Offrede"
output:
  html_document:
    toc: true
    toc_depth: 5
    toc_float: 
      collapsed: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
library(tidyverse)
library(lmerTest)
library(DHARMa)
library(broom)
library(parsnip)
library(emmeans)

load(paste0(here::here(), "/data/speechData.RData"))
load(paste0(here::here(), "/data/speechData-allIPUs.RData"))
load(paste0(here::here(), "/data/metadata-clean.RData"))
load(paste0(here::here(), "/data/individualTemp.RData"))
meta <- m
badFiles <- c(paste0("AML-D", c(1, 2)), paste0("FWR-L", c(1, 2, 3)), paste0("HAG-D", c(1, 2)), paste0("HBR-D", c(1, 2)), paste0("HBR-L", c(1, 2, 3)), paste0("HUJ-D", c(1, 2)), "KPB-D1", paste0("MJG-D", c(1, 2)), paste0("MJG-L", c(1, 2)), "OAL-D1", paste0("OAL-L", c(1, 2, 3)), paste0("OXQ-D", c(1, 2)), paste0("OXQ-L", c(1, 2, 3)), "SGB-D1", paste0("SGB-L", c(1, 2, 3)), paste0("SUK-D", c(1, 2)), "TTN-D1", paste0("TTN-L", c(1, 2, 3)), "TTY-D1", paste0("VDE-D", c(1, 2)), "ZNV-D1")
```

# Summary of results

**f0 change regardless of interlocutor** (per speaker; using categorical values)

* Some participants significantly increased or decreased on different f0 measures to different extents, but there were almost no relationships with other predictors. This is the exception:
    * First part of the experiment (Lists)
        * f0 max *decreased less often* when the speaker felt *closer* to their partner.
        * f0 max *decreased less often* when the speaker *liked* their partner *more* (small effect).
        * f0 SD tended to *increase more often* when the person scored higher in *neuroticism*.

**f0 change regardless of interlocutor** (all speakers together; using continuous values)

* First section of the experiment (Lists)
    * f0 median didn’t change in any condition.
    * f0 max tended to decrease only in the impersonal condition, but if we’re being strict (AIC of model with condition was 1.7 smaller than without), there f0 max went down in both conditions.
    * f0 SD decreased in both conditions.
* Second section of the experiment (Diapix)
    * f0 median increased in both conditions.
    * f0 max didn’t change significantly in either condition.
    * f0 SD didn’t change in either condition.
* Across entire experiment
    * f0 median increased in both conditions.
    * f0 max decreased in both conditions.
    * f0 SD didn’t change in either condition.

**f0 entrainment**

* Some participants entrained and some didn't; sometimes only in the first part of the experiment, sometimes in the second, sometimes across it all.
* The most common effect was of dyssynchrony, meaning the participants often produce different f0 from the previous turn's last IPU. Makes sense: question-answer.
* I didn't find any effects of condition or relationship with temperature change or questionnaire responses.

# Notes

* The check of residuals of logistic models below, was done following: <https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html>
* When analyzing the effect of temperature change (categorical, per speaker) on f0 change (categorical, per speaker), some effects were positive in the model; but some of the categories that produce "significance" have too few data points, so I don't consider those "significant" results as actually meaningful or significant. A couple of times that that happens are indicated in the detailed analysis below, but after a few times that that happened I just ignored it as "non significant".

# Individual change -- regardless of interlocutor

## Individual analysis

```{r}
ind <- data.frame(matrix(nrow=0, ncol=6))
names(ind) <- c("speaker", "condition", "feature", "section", "t", "p")
```

```{r}
for(s in unique(ipus$speaker)){
  # f0 median
  c <- tidy(lm(f0medz ~ turnOverall, ipus |> filter(speaker==s)))
  ind[nrow(ind)+1,] <- c(s, unique(ipus$condition[ipus$speaker==s]), "f0median", "entireExp",
                         c$statistic[2], c$p.value[2])
  c <- tidy(lm(f0medz ~ turnOverall, ipus |> filter(speaker==s, task=="Lists")))
  ind[nrow(ind)+1,] <- c(s, unique(ipus$condition[ipus$speaker==s]), "f0median", "Lists",
                         c$statistic[2], c$p.value[2])
  if(!all(is.na(ipus$f0medz[ipus$speaker==s & ipus$task=="Diapix"]))){ # need to do this because there are missing files for one dyad for this section
    c <- tidy(lm(f0medz ~ turnOverall, ipus |> filter(speaker==s, task=="Diapix")))
    ind[nrow(ind)+1,] <- c(s, unique(ipus$condition[ipus$speaker==s]), "f0median", "Diapix",
                           c$statistic[2], c$p.value[2])
  }
  
  # f0 max
  c <- tidy(lm(f0maxz ~ turnOverall, ipus |> filter(speaker==s)))
  ind[nrow(ind)+1,] <- c(s, unique(ipus$condition[ipus$speaker==s]), "f0max", "entireExp",
                         c$statistic[2], c$p.value[2])
  c <- tidy(lm(f0maxz ~ turnOverall, ipus |> filter(speaker==s, task=="Lists")))
  ind[nrow(ind)+1,] <- c(s, unique(ipus$condition[ipus$speaker==s]), "f0max", "Lists",
                         c$statistic[2], c$p.value[2])
  if(!all(is.na(ipus$f0maxz[ipus$speaker==s & ipus$task=="Diapix"]))){ # need to do this because there are missing files for one dyad for this section
    c <- tidy(lm(f0maxz ~ turnOverall, ipus |> filter(speaker==s, task=="Diapix")))
    ind[nrow(ind)+1,] <- c(s, unique(ipus$condition[ipus$speaker==s]), "f0max", "Diapix",
                           c$statistic[2], c$p.value[2])
  }
  
  # f0 SD
  c <- tidy(lm(f0sdz ~ turnOverall, ipus |> filter(speaker==s)))
  ind[nrow(ind)+1,] <- c(s, unique(ipus$condition[ipus$speaker==s]), "f0SD", "entireExp",
                         c$statistic[2], c$p.value[2])
  c <- tidy(lm(f0sdz ~ turnOverall, ipus |> filter(speaker==s, task=="Lists")))
  ind[nrow(ind)+1,] <- c(s, unique(ipus$condition[ipus$speaker==s]), "f0SD", "Lists",
                         c$statistic[2], c$p.value[2])
  if(!all(is.na(ipus$f0sdz[ipus$speaker==s & ipus$task=="Diapix"]))){ # need to do this because there are missing files for one dyad for this section
    c <- tidy(lm(f0sdz ~ turnOverall, ipus |> filter(speaker==s, task=="Diapix")))
    ind[nrow(ind)+1,] <- c(s, unique(ipus$condition[ipus$speaker==s]), "f0SD", "Diapix",
                           c$statistic[2], c$p.value[2])
  }
}

dat <- merge(ind |> 
               mutate_at(c("t", "p"), as.numeric) |> 
               mutate(change = case_when(
                 p < 0.05 & t < 0 ~ "decrease",
                 p < 0.05 & t > 0 ~ "increase",
                 p > 0.05 ~ "ns"
               )),
             ipus |> select(speaker, gender, comfortPre, comfortPost, closeness, similarity, likeability, becomeFriends, extraversion, openness, agreeableness, conscientiousness, neuroticism) |> filter(!duplicated(speaker)),
             by = "speaker") |> 
  mutate_at(c("speaker", "condition", "feature", "section", "change", "gender"), as.factor)

dat$change <- relevel(dat$change, ref="ns")
```

```{r}
# join individual temperature change effects
indTemp <- indTemp |> 
  mutate(effect = case_when(
    effect == "ns" ~ "tempNS",
    effect == "increase" ~ "tempIncrease",
    effect == "decrease" ~ "tempDecrease",
  ))

s <- dat |> 
  mutate(change = case_when(
    change == "ns" ~ "f0NS",
    change == "increase" ~ "f0Increase",
    change == "decrease" ~ "f0Decrease",
  ))

t1 <- indTemp |> 
  filter(section=="entireExp") |> 
  group_by(speaker) |>
  pivot_wider(names_from = ROI, values_from = effect, id_cols=speaker) |> 
  mutate(section = "entireExp")

t2 <- indTemp |> 
  filter(section=="Lists") |> 
  group_by(speaker) |>
  pivot_wider(names_from = ROI, values_from = effect, id_cols=speaker) |> 
  mutate(section = "Lists")

t3 <- indTemp |> 
  filter(section=="Diapix") |> 
  group_by(speaker) |>
  pivot_wider(names_from = ROI, values_from = effect, id_cols=speaker) |> 
  mutate(section = "Diapix")
# mutate(section = "Lists") # naming the Diapix section and "Lists" to pair these values with the f0 adaptation during "Lists", since temperature change takes a while to happen
# this didn't bring about any new insights

t <- rbind(t1, rbind(t2, t3))
# t <- rbind(t1, t3)

ts <- merge(t,
            s |> 
              select(-condition),
            by=c("speaker", "section"), all=TRUE) |> 
  mutate_at(c("speaker", "section", "Forehead", "Eyes", "Nose", "Cheeks", "feature", "change", "gender"), as.factor)

ts$Forehead <- relevel(ts$Forehead, ref="tempNS")
ts$Cheeks <- relevel(ts$Cheeks, ref="tempNS")
ts$Eyes <- relevel(ts$Eyes, ref="tempNS")
ts$Nose <- relevel(ts$Nose, ref="tempNS")
ts$change <- relevel(ts$change, ref="f0NS")
```


### Explore possible predictors

#### First part of the experiment (Lists)

##### f0 median

No effect of condition

```{r}
ggplot(dat |> filter(feature=="f0median", section=="Lists"), aes(condition, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("decrease" = "lightblue", "increase" = "red", "ns" = "gray"))+
  ggtitle("f0 median (first part of exp - Lists)")
```

```{r}
tidy(m <- nnet::multinom(change ~ condition, data=dat |> filter(feature=="f0median", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
emmeans(m, pairwise~condition, by="change")
```

No effect of perception of partner
```{r}
tidy(m <- nnet::multinom(change ~ closeness, data=dat |> filter(feature=="f0median", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ similarity, data=dat |> filter(feature=="f0median", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ likeability, data=dat |> filter(feature=="f0median", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ becomeFriends, data=dat |> filter(feature=="f0median", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of BFI scores
```{r}
tidy(m <- nnet::multinom(change ~ extraversion, data=dat |> filter(feature=="f0median", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ openness, data=dat |> filter(feature=="f0median", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ agreeableness, data=dat |> filter(feature=="f0median", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ conscientiousness, data=dat |> filter(feature=="f0median", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ neuroticism, data=dat |> filter(feature=="f0median", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of forehead temperature change on f0 median change
```{r}
ggplot(ts |> filter(section=="Lists", feature=="f0median", !is.na(Forehead)), aes(Forehead, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Forehead temp. change and f0 median change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Forehead, data=ts |> filter(feature=="f0median", section=="Lists", !is.na(Forehead)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Forehead, by="change")
```

No effect of nose temperature change on f0 median change
```{r}
ggplot(ts |> filter(section=="Lists", feature=="f0median", !is.na(Nose)), aes(Nose, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Nose temp. change and f0 median change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Nose, data=ts |> filter(feature=="f0median", section=="Lists", !is.na(Nose)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Nose, by="change")
```

No effect of eye temperature change on f0 median change
```{r}
ggplot(ts |> filter(section=="Lists", feature=="f0median", !is.na(Eyes)), aes(Eyes, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Eye temp. change and f0 median change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Eyes, data=ts |> filter(feature=="f0median", section=="Lists", !is.na(Eyes)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Eyes, by="change") # isn't working (I'm thinking maybe because "eyes" have lots of missing values)
```

No effect of cheek temperature change on f0 median change
```{r}
ggplot(ts |> filter(section=="Lists", feature=="f0median", , !is.na(Cheeks)), aes(Cheeks, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Cheek temp. change and f0 median change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Cheeks, data=ts |> filter(feature=="f0median", section=="Lists", !is.na(Cheeks)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Cheeks, by="change")
```

##### f0 max

No effect of condition

```{r}
ggplot(dat |> filter(feature=="f0max", section=="Lists"), aes(condition, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("decrease" = "lightblue", "increase" = "red", "ns" = "gray"))+
  ggtitle("f0 max (first part of exp - Lists)")
```

```{r}
tidy(m <- nnet::multinom(change ~ condition, data=dat |> filter(feature=="f0max", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
emmeans(m, pairwise~condition, by="change")
```

f0 max decreased *less* when the speaker felt *closer* to their partner.
```{r}
ggplot(dat |> filter(feature=="f0max", section=="Lists"), aes(change, closeness))+
  geom_boxplot()
```

```{r}
tidy(m <- nnet::multinom(change ~ closeness, data=dat |> filter(feature=="f0max", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

f0 max also decreased *less* (smaller effect) when the speaker *liked* their partner *more*.
```{r}
ggplot(dat |> filter(feature=="f0max", section=="Lists"), aes(change, likeability))+
  geom_boxplot()
```

```{r}
tidy(m <- nnet::multinom(change ~ likeability, data=dat |> filter(feature=="f0max", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ similarity, data=dat |> filter(feature=="f0max", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ becomeFriends, data=dat |> filter(feature=="f0max", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of BFI scores
```{r}
tidy(m <- nnet::multinom(change ~ extraversion, data=dat |> filter(feature=="f0max", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ openness, data=dat |> filter(feature=="f0max", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ agreeableness, data=dat |> filter(feature=="f0max", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ conscientiousness, data=dat |> filter(feature=="f0max", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ neuroticism, data=dat |> filter(feature=="f0max", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of forehead temperature change on f0 max change
```{r}
ggplot(ts |> filter(section=="Lists", feature=="f0max", !is.na(Forehead)), aes(Forehead, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Forehead temp. change and f0 max change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Forehead, data=ts |> filter(feature=="f0max", section=="Lists", !is.na(Forehead)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Forehead, by="change")
```

No effect of nose temperature change on f0 max change
```{r}
ggplot(ts |> filter(section=="Lists", feature=="f0max", !is.na(Nose)), aes(Nose, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Nose temp. change and f0 max change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Nose, data=ts |> filter(feature=="f0max", section=="Lists", !is.na(Nose)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Nose, by="change")
```

No effect of eye temperature change on f0 max change
```{r}
ggplot(ts |> filter(section=="Lists", feature=="f0max", !is.na(Eyes)), aes(Eyes, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Eye temp. change and f0 max change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Eyes, data=ts |> filter(feature=="f0max", section=="Lists", !is.na(Eyes)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Eyes, by="change") # isn't working (I'm thinking maybe because "eyes" have lots of missing values)
```

No effect of cheek temperature change on f0 max change
```{r}
ggplot(ts |> filter(section=="Lists", feature=="f0max", !is.na(Cheeks)), aes(Cheeks, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Cheek temp. change and f0 max change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Cheeks, data=ts |> filter(feature=="f0max", section=="Lists", !is.na(Cheeks)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Cheeks, by="change")
```

##### f0 SD

No effect of condition

```{r}
ggplot(dat |> filter(feature=="f0SD", section=="Lists"), aes(condition, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("decrease" = "lightblue", "increase" = "red", "ns" = "gray"))+
  ggtitle("f0 SD (first part of exp - Lists)")
```

```{r}
tidy(m <- nnet::multinom(change ~ condition, data=dat |> filter(feature=="f0SD", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
emmeans(m, pairwise~condition, by="change")
```

No effect of perception of partner
```{r}
tidy(m <- nnet::multinom(change ~ closeness, data=dat |> filter(feature=="f0SD", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ similarity, data=dat |> filter(feature=="f0SD", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ likeability, data=dat |> filter(feature=="f0SD", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ becomeFriends, data=dat |> filter(feature=="f0SD", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

f0 SD tended to increase *more* often when the person scored *higher* in *neuroticism*.
```{r}
ggplot(dat |> filter(feature=="f0max", section=="Lists"), aes(change, neuroticism))+
  geom_boxplot()
```

```{r}
tidy(m <- nnet::multinom(change ~ neuroticism, data=dat |> filter(feature=="f0SD", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ extraversion, data=dat |> filter(feature=="f0SD", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ openness, data=dat |> filter(feature=="f0SD", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ agreeableness, data=dat |> filter(feature=="f0SD", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ conscientiousness, data=dat |> filter(feature=="f0SD", section=="Lists"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of forehead temperature change on f0 SD change
```{r}
ggplot(ts |> filter(section=="Lists", feature=="f0SD", !is.na(Forehead)), aes(Forehead, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Forehead temp. change and f0 SD change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Forehead, data=ts |> filter(feature=="f0SD", section=="Lists", !is.na(Forehead)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Forehead, by="change")
```

No effect of nose temperature change on f0 SD change
```{r}
ggplot(ts |> filter(section=="Lists", feature=="f0SD", !is.na(Nose)), aes(Nose, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Nose temp. change and f0 SD change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Nose, data=ts |> filter(feature=="f0SD", section=="Lists", !is.na(Nose)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Nose, by="change")
```

No effect of eye temperature change on f0 SD change
(The model actually suggests that f0 SD decreased more when the temperature also decreased. But there are so few data points of `temperature decrease` that I don't think this is robust or meaningful.)
```{r}
ggplot(ts |> filter(section=="Lists", feature=="f0SD", !is.na(Eyes)), aes(Eyes, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Eye temp. change and f0 SD change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Eyes, data=ts |> filter(feature=="f0SD", section=="Lists", !is.na(Eyes)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Eyes, by="change") # isn't working (I'm thinking maybe because "eyes" have lots of missing values)
```

No effect of cheek temperature change on f0 SD change
```{r}
ggplot(ts |> filter(section=="Lists", feature=="f0SD", !is.na(Cheeks)), aes(Cheeks, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Cheek temp. change and f0 SD change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Cheeks, data=ts |> filter(feature=="f0SD", section=="Lists", !is.na(Cheeks)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Cheeks, by="change")
```

#### Second part of the experiment (Diapix)

##### f0 median

No effect of condition

```{r}
ggplot(dat |> filter(feature=="f0median", section=="Diapix"), aes(condition, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("decrease" = "lightblue", "increase" = "red", "ns" = "gray"))+
  ggtitle("f0 median (second part of exp - Diapix)")
```

```{r}
tidy(m <- nnet::multinom(change ~ condition, data=dat |> filter(feature=="f0median", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
emmeans(m, pairwise~condition, by="change")
```

No effect of perception of partner
```{r}
tidy(m <- nnet::multinom(change ~ closeness, data=dat |> filter(feature=="f0median", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ similarity, data=dat |> filter(feature=="f0median", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ likeability, data=dat |> filter(feature=="f0median", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ becomeFriends, data=dat |> filter(feature=="f0median", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of BFI scores
```{r}
tidy(m <- nnet::multinom(change ~ extraversion, data=dat |> filter(feature=="f0median", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ openness, data=dat |> filter(feature=="f0median", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ agreeableness, data=dat |> filter(feature=="f0median", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ conscientiousness, data=dat |> filter(feature=="f0median", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ neuroticism, data=dat |> filter(feature=="f0median", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of forehead temperature change on f0 median change
```{r}
ggplot(ts |> filter(section=="Diapix", feature=="f0median"), aes(Forehead, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Forehead temp. change and f0 median change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Forehead, data=ts |> filter(feature=="f0median", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Forehead, by="change")
```

No effect of nose temperature change on f0 median change
```{r}
ggplot(ts |> filter(section=="Diapix", feature=="f0median"), aes(Nose, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Nose temp. change and f0 median change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Nose, data=ts |> filter(feature=="f0median", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Nose, by="change")
```

No effect of eye temperature change on f0 median change
```{r}
ggplot(ts |> filter(section=="Diapix", feature=="f0median", !is.na(Eyes)), aes(Eyes, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Eye temp. change and f0 median change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Eyes, data=ts |> filter(feature=="f0median", section=="Diapix", !is.na(Eyes)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Eyes, by="change")
```

No effect of cheek temperature change on f0 median change
```{r}
ggplot(ts |> filter(section=="Diapix", feature=="f0median"), aes(Cheeks, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Cheek temp. change and f0 median change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Cheeks, data=ts |> filter(feature=="f0median", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Cheeks, by="change")
```

##### f0 max

No effect of condition

```{r}
ggplot(dat |> filter(feature=="f0max", section=="Diapix"), aes(condition, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("decrease" = "lightblue", "increase" = "red", "ns" = "gray"))+
  ggtitle("f0 max (second part of exp - Diapix)")
```

```{r}
tidy(m <- nnet::multinom(change ~ condition, data=dat |> filter(feature=="f0max", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
emmeans(m, pairwise~condition, by="change")
```

No effect of perception of partner
```{r}
tidy(m <- nnet::multinom(change ~ closeness, data=dat |> filter(feature=="f0max", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ similarity, data=dat |> filter(feature=="f0max", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ likeability, data=dat |> filter(feature=="f0max", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ becomeFriends, data=dat |> filter(feature=="f0max", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of BFI scores
```{r}
tidy(m <- nnet::multinom(change ~ extraversion, data=dat |> filter(feature=="f0max", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ openness, data=dat |> filter(feature=="f0max", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ agreeableness, data=dat |> filter(feature=="f0max", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ conscientiousness, data=dat |> filter(feature=="f0max", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ neuroticism, data=dat |> filter(feature=="f0max", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of forehead temperature change on f0 max change
```{r}
ggplot(ts |> filter(section=="Diapix", feature=="f0max"), aes(Forehead, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Forehead temp. change and f0 max change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Forehead, data=ts |> filter(feature=="f0max", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Forehead, by="change")
```

No effect of nose temperature change on f0 max change
```{r}
ggplot(ts |> filter(section=="Diapix", feature=="f0max"), aes(Nose, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Nose temp. change and f0 max change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Nose, data=ts |> filter(feature=="f0max", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Nose, by="change")
```

No effect of eye temperature change on f0 max change
```{r}
ggplot(ts |> filter(section=="Diapix", feature=="f0max", !is.na(Eyes)), aes(Eyes, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Eye temp. change and f0 max change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Eyes, data=ts |> filter(feature=="f0max", section=="Diapix", !is.na(Eyes)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Eyes, by="change")
```

No effect of cheek temperature change on f0 max change
```{r}
ggplot(ts |> filter(section=="Diapix", feature=="f0max"), aes(Cheeks, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Cheek temp. change and f0 max change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Cheeks, data=ts |> filter(feature=="f0max", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Cheeks, by="change")
```

##### f0 SD

No effect of condition

```{r}
ggplot(dat |> filter(feature=="f0SD", section=="Diapix"), aes(condition, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("decrease" = "lightblue", "increase" = "red", "ns" = "gray"))+
  ggtitle("f0 SD (second part of exp - Diapix)")
```

```{r}
tidy(m <- nnet::multinom(change ~ condition, data=dat |> filter(feature=="f0SD", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
emmeans(m, pairwise~condition, by="change")
```

No effect of perception of partner
```{r}
tidy(m <- nnet::multinom(change ~ closeness, data=dat |> filter(feature=="f0SD", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ similarity, data=dat |> filter(feature=="f0SD", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ likeability, data=dat |> filter(feature=="f0SD", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ becomeFriends, data=dat |> filter(feature=="f0SD", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of BFI scores
```{r}
tidy(m <- nnet::multinom(change ~ extraversion, data=dat |> filter(feature=="f0SD", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ openness, data=dat |> filter(feature=="f0SD", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ agreeableness, data=dat |> filter(feature=="f0SD", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ conscientiousness, data=dat |> filter(feature=="f0SD", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ neuroticism, data=dat |> filter(feature=="f0SD", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of forehead temperature change on f0 SD change
```{r}
ggplot(ts |> filter(section=="Diapix", feature=="f0SD"), aes(Forehead, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Forehead temp. change and f0 SD change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Forehead, data=ts |> filter(feature=="f0SD", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Forehead, by="change")
```

No effect of nose temperature change on f0 SD change
```{r}
ggplot(ts |> filter(section=="Diapix", feature=="f0SD"), aes(Nose, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Nose temp. change and f0 SD change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Nose, data=ts |> filter(feature=="f0SD", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Nose, by="change")
```

No effect of eye temperature change on f0 SD change
```{r}
ggplot(ts |> filter(section=="Diapix", feature=="f0SD", !is.na(Eyes)), aes(Eyes, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Eye temp. change and f0 SD change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Eyes, data=ts |> filter(feature=="f0SD", section=="Diapix", !is.na(Eyes)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Eyes, by="change") # isn't working (I'm thinking maybe because "eyes" have lots of missing values)
```

No effect of cheek temperature change on f0 SD change
```{r}
ggplot(ts |> filter(section=="Diapix", feature=="f0SD"), aes(Cheeks, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Cheek temp. change and f0 SD change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Cheeks, data=ts |> filter(feature=="f0SD", section=="Diapix"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Cheeks, by="change")
```

#### Across entire experiment

##### f0 median

No effect of condition

```{r}
ggplot(dat |> filter(feature=="f0median", section=="entireExp"), aes(condition, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("decrease" = "lightblue", "increase" = "red", "ns" = "gray"))+
  ggtitle("f0 median across entire experiment")
```

```{r}
tidy(m <- nnet::multinom(change ~ condition, data=dat |> filter(feature=="f0median", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
emmeans(m, pairwise~condition, by="change")
```

No effect of perception of partner
```{r}
tidy(m <- nnet::multinom(change ~ closeness, data=dat |> filter(feature=="f0median", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ similarity, data=dat |> filter(feature=="f0median", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ likeability, data=dat |> filter(feature=="f0median", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ becomeFriends, data=dat |> filter(feature=="f0median", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of BFI scores
```{r}
tidy(m <- nnet::multinom(change ~ extraversion, data=dat |> filter(feature=="f0median", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ openness, data=dat |> filter(feature=="f0median", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ agreeableness, data=dat |> filter(feature=="f0median", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ conscientiousness, data=dat |> filter(feature=="f0median", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ neuroticism, data=dat |> filter(feature=="f0median", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of forehead temperature change on f0 median change
```{r}
ggplot(ts |> filter(section=="entireExp", feature=="f0median"), aes(Forehead, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Forehead temp. change and f0 median change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Forehead, data=ts |> filter(feature=="f0median", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Forehead, by="change")
```

No effect of nose temperature change on f0 median change
```{r}
ggplot(ts |> filter(section=="entireExp", feature=="f0median"), aes(Nose, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Nose temp. change and f0 median change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Nose, data=ts |> filter(feature=="f0median", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Nose, by="change")
```

No effect of eye temperature change on f0 median change
```{r}
ggplot(ts |> filter(section=="entireExp", feature=="f0median", !is.na(Eyes)), aes(Eyes, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Eye temp. change and f0 median change")
```

The model is weirdly producing NaNs for the category `tempDecrease` even when I've explicitly removed the NA values in the dataset (and also after `droplevel`-ing it). But anyway, there are such few values in the `tempNS` category that a real comparison wouldn't have been meaningful, like for other models above.
```{r}
tidy(m <- nnet::multinom(change ~ Eyes, data=ts |> filter(feature=="f0median", section=="entireExp", !is.na(Eyes)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
# emmeans(m, pairwise~Eyes, by="change")
```

No effect of cheek temperature change on f0 median change
```{r}
ggplot(ts |> filter(section=="entireExp", feature=="f0median") |> drop_na(), aes(Cheeks, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Cheek temp. change and f0 median change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Cheeks, data=ts |> filter(feature=="f0median", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Cheeks, by="change")
```

##### f0 max

No effect of condition

```{r}
ggplot(dat |> filter(feature=="f0max", section=="entireExp"), aes(condition, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("decrease" = "lightblue", "increase" = "red", "ns" = "gray"))+
  ggtitle("f0 max across entire experiment")
```

```{r}
tidy(m <- nnet::multinom(change ~ condition, data=dat |> filter(feature=="f0max", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
emmeans(m, pairwise~condition, by="change")
```

No effect of perception of partner
```{r}
tidy(m <- nnet::multinom(change ~ closeness, data=dat |> filter(feature=="f0max", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ similarity, data=dat |> filter(feature=="f0max", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ likeability, data=dat |> filter(feature=="f0max", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ becomeFriends, data=dat |> filter(feature=="f0max", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of BFI scores
```{r}
tidy(m <- nnet::multinom(change ~ extraversion, data=dat |> filter(feature=="f0max", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ openness, data=dat |> filter(feature=="f0max", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ agreeableness, data=dat |> filter(feature=="f0max", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ conscientiousness, data=dat |> filter(feature=="f0max", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ neuroticism, data=dat |> filter(feature=="f0max", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of forehead temperature change on f0 max change
```{r}
ggplot(ts |> filter(section=="entireExp", feature=="f0max"), aes(Forehead, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Forehead temp. change and f0 max change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Forehead, data=ts |> filter(feature=="f0max", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Forehead, by="change")
```

No effect of nose temperature change on f0 max change
```{r}
ggplot(ts |> filter(section=="entireExp", feature=="f0max"), aes(Nose, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Nose temp. change and f0 max change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Nose, data=ts |> filter(feature=="f0max", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Nose, by="change")
```

No effect of eye temperature change on f0 max change (but again, model not working even after filtering out NAs...)
```{r}
ggplot(ts |> filter(section=="entireExp", feature=="f0max", !is.na(Eyes)), aes(Eyes, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Eye temp. change and f0 max change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Eyes, data=ts |> filter(feature=="f0max", section=="entireExp", !is.na(Eyes)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
# emmeans(m, pairwise~Eyes, by="change")
```

No effect of cheek temperature change on f0 max change
```{r}
ggplot(ts |> filter(section=="entireExp", feature=="f0max"), aes(Cheeks, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Cheek temp. change and f0 max change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Cheeks, data=ts |> filter(feature=="f0max", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Cheeks, by="change")
```

##### f0 SD

No effect of condition

```{r}
ggplot(dat |> filter(feature=="f0SD", section=="entireExp"), aes(condition, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("decrease" = "lightblue", "increase" = "red", "ns" = "gray"))+
  ggtitle("f0 SD across entire experiment")
```

```{r}
tidy(m <- nnet::multinom(change ~ condition, data=dat |> filter(feature=="f0SD", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
emmeans(m, pairwise~condition, by="change")
```

No effect of perception of partner
```{r}
tidy(m <- nnet::multinom(change ~ closeness, data=dat |> filter(feature=="f0SD", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ similarity, data=dat |> filter(feature=="f0SD", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ likeability, data=dat |> filter(feature=="f0SD", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ becomeFriends, data=dat |> filter(feature=="f0SD", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of BFI scores
```{r}
tidy(m <- nnet::multinom(change ~ extraversion, data=dat |> filter(feature=="f0SD", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ openness, data=dat |> filter(feature=="f0SD", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ agreeableness, data=dat |> filter(feature=="f0SD", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ conscientiousness, data=dat |> filter(feature=="f0SD", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(change ~ neuroticism, data=dat |> filter(feature=="f0SD", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of forehead temperature change on f0 SD change
```{r}
ggplot(ts |> filter(section=="entireExp", feature=="f0SD"), aes(Forehead, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Forehead temp. change and f0 SD change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Forehead, data=ts |> filter(feature=="f0SD", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Forehead, by="change")
```

No effect of nose temperature change on f0 SD change
```{r}
ggplot(ts |> filter(section=="entireExp", feature=="f0SD"), aes(Nose, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Nose temp. change and f0 SD change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Nose, data=ts |> filter(feature=="f0SD", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Nose, by="change")
```

No effect of eye temperature change on f0 SD change
```{r}
ggplot(ts |> filter(section=="entireExp", feature=="f0SD", !is.na(Eyes)), aes(Eyes, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Eye temp. change and f0 SD change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Eyes, data=ts |> filter(feature=="f0SD", section=="entireExp", !is.na(Eyes)))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
# emmeans(m, pairwise~Eyes, by="change") # isn't working (I'm thinking maybe because "eyes" have lots of missing values)
```

No effect of cheek temperature change on f0 SD change
```{r}
ggplot(ts |> filter(section=="entireExp", feature=="f0SD"), aes(Cheeks, fill=change))+
  geom_bar()+
  scale_fill_manual(values = c("f0Decrease" = "lightblue", "f0Increase" = "red", "f0NS" = "gray"))+
  ggtitle("Cheek temp. change and f0 SD change")
```

```{r}
tidy(m <- nnet::multinom(change ~ Cheeks, data=ts |> filter(feature=="f0SD", section=="entireExp"))) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
emmeans(m, pairwise~Cheeks, by="change")
```

## All speakers pulled together

### f0 median

-   Across entire experiment: f0 median increases in both conditions.
-   Only during question lists: f0 median doesn't change in any condition.
-   Only during Diapix: f0 median increases in both conditions.

```{r}
load(paste0(here::here(), "/data/speechData-allIPUs.RData"))
# ipus <- ipus |> 
#   filter(gender != "Male")
```

```{r}
ggplot(ipus, aes(turnOverall, f0medz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Entire experiment")
summary(m <- lmer(f0medz ~ turnOverall + (1|speaker), ipus))
summary(m1 <- lmer(f0medz ~ turnOverall : condition + (1|speaker), ipus))
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```
```{r}
ggplot(ipus |> filter(task=="Lists"), aes(turnOverall, f0medz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Question lists (1st part of experiment)")
summary(m <- lmer(f0medz ~ turnOverall + (1|speaker), ipus |> filter(task=="Lists")))
summary(m1 <- lmer(f0medz ~ turnOverall : condition + (1|speaker), ipus |> filter(task=="Lists")))
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```
```{r}
ggplot(ipus |> filter(task=="Diapix"), aes(turnOverall, f0medz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Diapix (2nd part of experiment)")
summary(m <- lmer(f0medz ~ turnOverall + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m1 <- lmer(f0medz ~ turnOverall : condition + (1|speaker), ipus |> filter(task=="Diapix")))
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```

Checking if f0 median changes across time in interaction with questionnaire scores: Even though many of the models are significant, their AIC is not preferred over the model without the questionnaire scores.

```{r}
summary(m <- lmer(f0medz ~ turnOverall + (1|speaker), ipus))
summary(m1 <- lmer(f0medz ~ turnOverall : closeness + (1|speaker), ipus))
summary(m2 <- lmer(f0medz ~ turnOverall : similarity + (1|speaker), ipus))
summary(m3 <- lmer(f0medz ~ turnOverall : likeability + (1|speaker), ipus))
summary(m4 <- lmer(f0medz ~ turnOverall : becomeFriends + (1|speaker), ipus))

anova(m, m1)
anova(m, m2)
anova(m, m3)
anova(m, m4)
```

### f0 max

-   Across entire experiment: f0 max decreases in both conditions.
-   Only during question lists: f0 max tends to decrease only in the *impersonal* condition, but if we're being strict (AIC of model with `condition` was 1.7 smaller than without), there f0 max went down in both conditions.
-   Only during Diapix: f0 max doesn't change significantly for either group.

```{r}
load(paste0(here::here(), "/data/speechData-allIPUs.RData"))
# ipus <- ipus |>
#   filter(gender != "Male")
```

```{r}
ggplot(ipus, aes(turnOverall, f0maxz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Entire experiment")
summary(m <- lm(f0maxz ~ turnOverall, ipus))
summary(m1 <- lm(f0maxz ~ turnOverall : condition, ipus))
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```
```{r}
ggplot(ipus |> filter(task=="Lists"), aes(turnOverall, f0maxz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Question lists (1st part of experiment)")
summary(m <- lmer(f0maxz ~ turnOverall + (1|speaker), ipus |> filter(task=="Lists")))
summary(m1 <- lmer(f0maxz ~ turnOverall : condition + (1|speaker), ipus |> filter(task=="Lists")))
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```
```{r}
ggplot(ipus |> filter(task=="Diapix"), aes(turnOverall, f0maxz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Diapix (2nd part of experiment)")
summary(m <- lmer(f0maxz ~ turnOverall + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m1 <- lmer(f0maxz ~ turnOverall : condition + (1|speaker), ipus |> filter(task=="Diapix")))
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```

Checking if f0 SD changes across time in interaction with questionnaire scores: Even though many of the models are significant, their AIC is not preferred over the model without the questionnaire scores.

```{r}
summary(m <- lmer(f0maxz ~ turnOverall + (1|speaker), ipus))
summary(m1 <- lmer(f0maxz ~ turnOverall : closeness + (1|speaker), ipus))
summary(m2 <- lmer(f0maxz ~ turnOverall : similarity + (1|speaker), ipus))
summary(m3 <- lmer(f0maxz ~ turnOverall : likeability + (1|speaker), ipus))
summary(m4 <- lmer(f0maxz ~ turnOverall : becomeFriends + (1|speaker), ipus))

anova(m, m1)
anova(m, m2)
anova(m, m3)
anova(m, m4)
```

### f0 SD

-   Across entire experiment: f0 SD doesn't change in either condition.
-   Only during question lists: f0 SD decreases in both conditions.
-   Only during Diapix: f0 SD doesn't change in either condition.

```{r}
load(paste0(here::here(), "/data/speechData-allIPUs.RData"))
# ipus <- ipus |>
#   filter(gender != "Male")
```

```{r}
ggplot(ipus, aes(turnOverall, f0sdz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Entire experiment")
summary(m <- lmer(f0sdz ~ turnOverall + (1|speaker), ipus))
summary(m1 <- lmer(f0sdz ~ turnOverall : condition + (1|speaker), ipus))
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```
```{r}
ggplot(ipus |> filter(task=="Lists"), aes(turnOverall, f0sdz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Question lists (1st part of experiment)")
summary(m <- lmer(f0sdz ~ turnOverall + (1|speaker), ipus |> filter(task=="Lists")))
summary(m1 <- lmer(f0sdz ~ turnOverall : condition + (1|speaker), ipus |> filter(task=="Lists")))
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```
```{r}
ggplot(ipus |> filter(task=="Diapix"), aes(turnOverall, f0sdz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Diapix (2nd part of experiment)")
summary(m <- lmer(f0sdz ~ turnOverall + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m1 <- lmer(f0sdz ~ turnOverall : condition + (1|speaker), ipus |> filter(task=="Diapix")))
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```

Checking if f0 SD changes across time in interaction with questionnaire scores: Even though many of the models are significant, their AIC is not preferred over the model without the questionnaire scores.

```{r}
summary(m <- lmer(f0sdz ~ turnOverall + (1|speaker), ipus))
summary(m1 <- lmer(f0sdz ~ turnOverall : closeness + (1|speaker), ipus))
summary(m2 <- lmer(f0sdz ~ turnOverall : similarity + (1|speaker), ipus))
summary(m3 <- lmer(f0sdz ~ turnOverall : likeability + (1|speaker), ipus))
summary(m4 <- lmer(f0sdz ~ turnOverall : becomeFriends + (1|speaker), ipus))

anova(m, m1)
anova(m, m2)
anova(m, m3)
anova(m, m4)
```

### All f0 measures & IPU length

(These analyses are using the non-z-scored values.)

**f0 median**: the regression suggests a negative relationship between f0 median and IPU duration, but the residuals are very heteroskedastic and a look at the raw data shows it's more complex than that.
```{r}
ggplot(ipus, aes(f0med, ipuDur))+
  geom_point()+
  geom_smooth()
summary(m <- lmer(f0med ~ ipuDur + (1|speaker), ipus))
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```

**f0 max**: it's a more robust finding that longer IPUs have higher f0 max values.
```{r}
ggplot(ipus, aes(f0max, ipuDur))+
  geom_point()+
  geom_smooth()
summary(m <- lmer(f0max ~ ipuDur + (1|speaker), ipus))
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```

**f0 SD**: again, a positive relation is suggested between f0 SD and IPU duration, but the plot shows it isn't linear, and the residuals are again very heteroskedastic.
```{r}
ggplot(ipus, aes(f0sd, ipuDur))+
  geom_point()+
  geom_smooth()
summary(m <- lm(f0sd ~ ipuDur, ipus))
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```


### Without domino task

```{r, include=FALSE}
load(paste0(here::here(), "/data/speechData-allIPUs.RData"))
ipus <- merge(ipus, 
              read.csv("C:/Users/offredet/Documents/1HU/ExperimentTemperature/Data/dominoTiming.csv", sep=";"),
              by = "dyad", all=TRUE) |> 
  mutate_at(c("dominoOnset", "dominoOffset"), as.numeric) |>  
  mutate(delete = ifelse(
    condition == "impersonal" & grepl("L3", file) & turnOnset > dominoOnset & turnOffset < dominoOffset,
    "del",
    "keep"
  )) |>
  filter(delete == "keep") |> 
  select(-delete) |> 
  group_by(speaker) |> 
  mutate(f0meanz = (f0mean - mean(f0mean, na.rm=TRUE)) / sd(f0mean, na.rm=TRUE),
         f0medz = (f0med - mean(f0med, na.rm=TRUE)) / sd(f0med, na.rm=TRUE),
         f0sdz = (f0sd - mean(f0sd, na.rm=TRUE)) / sd(f0sd, na.rm=TRUE),
         f0maxz = (f0max - mean(f0max, na.rm=TRUE)) / sd(f0max, na.rm=TRUE)) |> 
  ungroup()
```

#### f0 median

-   Across entire experiment: f0 median increases in both conditions.
-   Only during question lists: f0 median doesn't change in any condition.
-   Only during Diapix: f0 median increases in both conditions.

```{r}
ggplot(ipus, aes(turnOverall, f0medz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Entire experiment")
summary(m <- lmer(f0medz ~ turnOverall + (1|speaker), ipus)) # the model is singular, so adding or removing random effects isn't making any difference
summary(m1 <- lmer(f0medz ~ turnOverall : condition + (1|speaker), ipus))
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```
```{r}
ggplot(ipus |> filter(task=="Lists"), aes(turnOverall, f0medz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Question lists (1st part of experiment)")
summary(m <- lmer(f0medz ~ turnOverall + (1|speaker), ipus |> filter(task=="Lists")))
summary(m1 <- lmer(f0medz ~ turnOverall : condition + (1|speaker), ipus |> filter(task=="Lists")))
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```
```{r}
ggplot(ipus |> filter(task=="Diapix"), aes(turnOverall, f0medz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Diapix (2nd part of experiment)")
summary(m <- lmer(f0medz ~ turnOverall + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m1 <- lmer(f0medz ~ turnOverall : condition + (1|speaker), ipus |> filter(task=="Diapix"))) # this was the preferred model, even if the effect for both 
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m1))
qqnorm(resid(m1));qqline(resid(m1))
plot(fitted(m1), resid(m1))
```

Checking if f0 median changes across time in interaction with questionnaire scores: Even though many of the models are significant, their AIC is not preferred over the model without the questionnaire scores.

```{r}
# entire experiment
summary(m <- lmer(f0medz ~ turnOverall + (1|speaker), ipus))
summary(m1 <- lmer(f0medz ~ turnOverall : closeness + (1|speaker), ipus))
summary(m2 <- lmer(f0medz ~ turnOverall : similarity + (1|speaker), ipus))
summary(m3 <- lmer(f0medz ~ turnOverall : likeability + (1|speaker), ipus))
summary(m4 <- lmer(f0medz ~ turnOverall : becomeFriends + (1|speaker), ipus))

anova(m, m1)
anova(m, m2)
anova(m, m3)
anova(m, m4)

# lists
summary(m <- lmer(f0medz ~ turnOverall + (1|speaker), ipus |> filter(task=="Lists")))
summary(m1 <- lmer(f0medz ~ turnOverall : closeness + (1|speaker), ipus |> filter(task=="Lists")))
summary(m2 <- lmer(f0medz ~ turnOverall : similarity + (1|speaker), ipus |> filter(task=="Lists")))
summary(m3 <- lmer(f0medz ~ turnOverall : likeability + (1|speaker), ipus |> filter(task=="Lists")))
summary(m4 <- lmer(f0medz ~ turnOverall : becomeFriends + (1|speaker), ipus |> filter(task=="Lists")))

anova(m, m1)
anova(m, m2)
anova(m, m3)
anova(m, m4)

# diapix
summary(m <- lmer(f0medz ~ turnOverall + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m1 <- lmer(f0medz ~ turnOverall : closeness + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m2 <- lmer(f0medz ~ turnOverall : similarity + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m3 <- lmer(f0medz ~ turnOverall : likeability + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m4 <- lmer(f0medz ~ turnOverall : becomeFriends + (1|speaker), ipus |> filter(task=="Diapix")))

anova(m, m1)
anova(m, m2)
anova(m, m3)
anova(m, m4)
```

#### f0 max

-   Across entire experiment: f0 max decreases in both conditions.
-   Only during question lists: f0 max doesn't change in either condition.
-   Only during Diapix: f0 max doesn't change in either condition.

```{r}
ggplot(ipus, aes(turnOverall, f0maxz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Entire experiment")
summary(m <- lm(f0maxz ~ turnOverall, ipus))
summary(m1 <- lm(f0maxz ~ turnOverall : condition, ipus))
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```
```{r}
ggplot(ipus |> filter(task=="Lists"), aes(turnOverall, f0maxz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Question lists (1st part of experiment)")
summary(m <- lmer(f0maxz ~ turnOverall + (1|speaker), ipus |> filter(task=="Lists")))
summary(m1 <- lmer(f0maxz ~ turnOverall : condition + (1|speaker), ipus |> filter(task=="Lists")))
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```
```{r}
ggplot(ipus |> filter(task=="Diapix"), aes(turnOverall, f0maxz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Diapix (2nd part of experiment)")
summary(m <- lmer(f0maxz ~ turnOverall + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m1 <- lmer(f0maxz ~ turnOverall : condition + (1|speaker), ipus |> filter(task=="Diapix")))
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```

Checking if f0 SD changes across time in interaction with questionnaire scores: Even though many of the models are significant, their AIC is not preferred over the model without the questionnaire scores.
One exception: f0 max seems to have decreased more for people that felt closer to their partner.

```{r}
# entire experiment
summary(m <- lmer(f0maxz ~ turnOverall + (1|speaker), ipus))
summary(m1 <- lmer(f0maxz ~ turnOverall : closeness + (1|speaker), ipus))
summary(m2 <- lmer(f0maxz ~ turnOverall : similarity + (1|speaker), ipus))
summary(m3 <- lmer(f0maxz ~ turnOverall : likeability + (1|speaker), ipus))
summary(m4 <- lmer(f0maxz ~ turnOverall : becomeFriends + (1|speaker), ipus))

anova(m, m1)
anova(m, m2)
anova(m, m3)
anova(m, m4)

# lists
summary(m <- lmer(f0maxz ~ turnOverall + (1|speaker), ipus |> filter(task=="Lists")))
summary(m1 <- lmer(f0maxz ~ turnOverall : closeness + (1|speaker), ipus |> filter(task=="Lists")))
summary(m2 <- lmer(f0maxz ~ turnOverall : similarity + (1|speaker), ipus |> filter(task=="Lists")))
summary(m3 <- lmer(f0maxz ~ turnOverall : likeability + (1|speaker), ipus |> filter(task=="Lists")))
summary(m4 <- lmer(f0maxz ~ turnOverall : becomeFriends + (1|speaker), ipus |> filter(task=="Lists")))

anova(m, m1)
anova(m, m2)
anova(m, m3)
anova(m, m4)

# diapix
summary(m <- lmer(f0maxz ~ turnOverall + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m1 <- lmer(f0maxz ~ turnOverall : closeness + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m2 <- lmer(f0maxz ~ turnOverall : similarity + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m3 <- lmer(f0maxz ~ turnOverall : likeability + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m4 <- lmer(f0maxz ~ turnOverall : becomeFriends + (1|speaker), ipus |> filter(task=="Diapix")))

anova(m, m1)
anova(m, m2)
anova(m, m3)
anova(m, m4)
```

#### f0 SD

-   Across entire experiment: f0 SD doesn't change in either condition.
-   Only during question lists: f0 SD decreases in both conditions.
-   Only during Diapix: f0 SD doesn't change in either condition.

```{r}
ggplot(ipus, aes(turnOverall, f0sdz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Entire experiment")
summary(m <- lmer(f0sdz ~ turnOverall + (1|speaker), ipus))
summary(m1 <- lmer(f0sdz ~ turnOverall : condition + (1|speaker), ipus))
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```
```{r}
ggplot(ipus |> filter(task=="Lists"), aes(turnOverall, f0sdz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Question lists (1st part of experiment)")
summary(m <- lmer(f0sdz ~ turnOverall + (1|speaker), ipus |> filter(task=="Lists")))
summary(m1 <- lmer(f0sdz ~ turnOverall : condition + (1|speaker), ipus |> filter(task=="Lists")))
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```
```{r}
ggplot(ipus |> filter(task=="Diapix"), aes(turnOverall, f0sdz))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)+
  ggtitle("Diapix (2nd part of experiment)")
summary(m <- lmer(f0sdz ~ turnOverall + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m1 <- lmer(f0sdz ~ turnOverall : condition + (1|speaker), ipus |> filter(task=="Diapix")))
anova(m, m1)
par(mfrow=c(2, 2))
hist(resid(m))
qqnorm(resid(m));qqline(resid(m))
plot(fitted(m), resid(m))
```

Checking if f0 SD changes across time in interaction with questionnaire scores: Even though many of the models are significant, their AIC is not preferred over the model without the questionnaire scores.

```{r}
# entire experiment
summary(m <- lmer(f0sdz ~ turnOverall + (1|speaker), ipus))
summary(m1 <- lmer(f0sdz ~ turnOverall : closeness + (1|speaker), ipus))
summary(m2 <- lmer(f0sdz ~ turnOverall : similarity + (1|speaker), ipus))
summary(m3 <- lmer(f0sdz ~ turnOverall : likeability + (1|speaker), ipus))
summary(m4 <- lmer(f0sdz ~ turnOverall : becomeFriends + (1|speaker), ipus))

anova(m, m1)
anova(m, m2)
anova(m, m3)
anova(m, m4)

# lists
summary(m <- lmer(f0sdz ~ turnOverall + (1|speaker), ipus |> filter(task=="Lists")))
summary(m1 <- lmer(f0sdz ~ turnOverall : closeness + (1|speaker), ipus |> filter(task=="Lists")))
summary(m2 <- lmer(f0sdz ~ turnOverall : similarity + (1|speaker), ipus |> filter(task=="Lists")))
summary(m3 <- lmer(f0sdz ~ turnOverall : likeability + (1|speaker), ipus |> filter(task=="Lists")))
summary(m4 <- lmer(f0sdz ~ turnOverall : becomeFriends + (1|speaker), ipus |> filter(task=="Lists")))

anova(m, m1)
anova(m, m2)
anova(m, m3)
anova(m, m4)

# diapix
summary(m <- lmer(f0sdz ~ turnOverall + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m1 <- lmer(f0sdz ~ turnOverall : closeness + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m2 <- lmer(f0sdz ~ turnOverall : similarity + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m3 <- lmer(f0sdz ~ turnOverall : likeability + (1|speaker), ipus |> filter(task=="Diapix")))
summary(m4 <- lmer(f0sdz ~ turnOverall : becomeFriends + (1|speaker), ipus |> filter(task=="Diapix")))

anova(m, m1)
anova(m, m2)
anova(m, m3)
anova(m, m4)
```

# Local convergence

(following Levitan & Hirschberg 2011's method)

```{r}
load(paste0(here::here(), "/data/speechData.RData"))

all <- data.frame(matrix(nrow=0, ncol=9))
names(all) <- c("speaker", "type", "direction", "coefficient", "mock", "real", "condition", "feature", "section")
```

## f0 median

### Across the entire experiment

```{r}
ggplot(dat, aes(turnOverall, f0medDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0medDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMedDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "entireExp",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the only 3 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged and two diverged on f0 median. All from the impersonal condition.

```{r}
print(count)
```

### Only in the first part of the experiment

Since we could argue that the speakers converge to each other only in the beginning, and that in the second part of the experiment the difference between f0s doesn't keep decreasing (or increasing)

```{r}
ggplot(dat |> filter(task=="Lists"), aes(turnOverall, f0medDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0medDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMedDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "Lists",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the only 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged (in the close condition) and one diverged (impersonal condition) on f0 median. These 2 are different from the 3 displayed above.

```{r}
print(count)
```

### Only in the second part of the experiment

Since we could argue that the speakers converge to each other more in the second part of the experiment, after they already got to know each other (and like each other or not) in the first part.

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(turnOverall, f0medDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0medDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMedDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "Diapix",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the only speaker whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

She was in the close condition and converged to her partner.

```{r}
print(count)
```

## f0 max

### Across the entire experiment

```{r}
ggplot(dat, aes(turnOverall, f0maxDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0maxDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMaxDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "entireExp",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

No one seemed to converge or diverge on f0 max.

```{r}
print(count)
```

### Only in the first part of the experiment

Since we could argue that the speakers converge to each other only in the beginning, and that in the second part of the experiment the difference between f0s doesn't keep decreasing (or increasing)

```{r}
ggplot(dat |> filter(task=="Lists"), aes(turnOverall, f0maxDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0maxDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMaxDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "Lists",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the only 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged (in the close condition) and one diverged (impersonal condition) on f0 max.

```{r}
print(count)
```

### Only in the second part of the experiment

Since we could argue that the speakers converge to each other more in the second part of the experiment, after they already got to know each other (and like each other or not) in the first part.

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(turnOverall, f0maxDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0maxDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMaxDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "Diapix",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the only 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One diverged and one converged on f0 max. Both were in the impersonal condition.

```{r}
print(count)
```

## f0 SD

### Across the entire experiment

```{r}
ggplot(dat, aes(turnOverall, f0sdDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0sdDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSdDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "entireExp",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

No one seemed to converge or diverge on f0 sd.

```{r}
print(count)
```

### Only in the first part of the experiment

Since we could argue that the speakers converge to each other only in the beginning, and that in the second part of the experiment the difference between f0s doesn't keep decreasing (or increasing)

```{r}
ggplot(dat |> filter(task=="Lists"), aes(turnOverall, f0sdDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0sdDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSdDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "Lists",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the only 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged (in the impersonal condition) and one diverged (close condition) on f0 sd.

```{r}
print(count)
```

### Only in the second part of the experiment

Since we could argue that the speakers converge to each other more in the second part of the experiment, after they already got to know each other (and like each other or not) in the first part.

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(turnOverall, f0sdDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0sdDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSdDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "Diapix",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the only 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged (in the impersonal condition) and one diverged (close condition) on f0 sd.

```{r}
print(count)
```

# Local Synchrony

## f0 median

### Across the entire experiment

```{r}
ggplot(dat, aes(f0medzGender, prevf0med))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0medzGender, d$prevf0med,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMed", i)], d$f0medzGender,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "entireExp",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the 4 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged (impersonal condition) and three diverged (2 in impersonal and 1 in close condition.)

```{r}
print(count)
```

### Only in the first part of the experiment

```{r}
ggplot(dat |> filter(task=="Lists"), aes(f0medzGender, prevf0med))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0medzGender, d$prevf0med,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMed", i)], d$f0medzGender,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "Lists",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the 4 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One in the close condition synchronized and two in the close condition desynchronized. One in the impersonal condition desynchronized.

```{r}
print(count)
```

### Only in the second part of the experiment

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(f0medzGender, prevf0med))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0medzGender, d$prevf0med,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMed", i)], d$f0medzGender,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "Diapix",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the 3 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

All three desynchronized. One in the close condition and two in the impersonal condition.

```{r}
print(count)
```

## f0 max

### Across the entire experiment

```{r}
ggplot(dat, aes(f0maxzGender, prevf0max))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0maxzGender, d$prevf0max,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMax", i)], d$f0maxzGender,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "entireExp",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the 8 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

All desynchronized. Two in the close condition and six in the impersonal condition.

```{r}
print(count)
```

### Only in the first part of the experiment

```{r}
ggplot(dat |> filter(task=="Lists"), aes(f0maxzGender, prevf0max))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0maxzGender, d$prevf0max,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMax", i)], d$f0maxzGender,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "Lists",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the only speaker whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

She was in the impersonal condition and desynchronized.

```{r}
print(count)
```

### Only in the second part of the experiment

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(f0maxzGender, prevf0max))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0maxzGender, d$prevf0max,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMax", i)], d$f0maxzGender,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "Diapix",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the 3 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

All desynchronized, one in the close and two in the impersonal condition.

```{r}
print(count)
```

## f0 SD

### Across the entire experiment

```{r}
ggplot(dat, aes(f0sdzGender, prevf0sd))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0sdzGender, d$prevf0sd,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSd", i)], d$f0sdzGender,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "entireExp",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the 5 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One synchronized (close condition). Four desynchronized (two close and two impersonal condition).

```{r}
print(count)
```

### Only in the first part of the experiment

```{r}
ggplot(dat |> filter(task=="Lists"), aes(f0sdzGender, prevf0sd))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0sdzGender, d$prevf0sd,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSd", i)], d$f0sdzGender,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "Lists",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

Both desynchronized and were in the close condition.

```{r}
print(count)
```

### Only in the second part of the experiment

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(f0sdzGender, prevf0sd))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0sdzGender, d$prevf0sd,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSd", i)], d$f0sdzGender,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "Diapix",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the 4 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

All desynchronized -- two in the close and two in the impersonal condition.

```{r}
print(count)
```

# All effects

```{r}
all <- all |> 
  mutate(sectionN = case_when(
    section=="entireExp" ~ 1,
    section=="Lists" ~ 2,
    section=="Diapix" ~ 3
  )) |> 
  rename(entrain=real) |> 
  arrange(sectionN) |> 
  select(-sectionN)
print(all |> filter(entrain=="yes"))
```

Most effects were when we take the entire experiment. But a considerable number of effects in each section too. (Note: the higher number of effects across the whole experiment should *not* be because of the increased number of datapoints, since we do a robustness check with 10 pseudo-datapoints to control for number of points.)

```{r}
table(all$section[all$entrain=="yes"])
table(paste(all$section[all$entrain=="yes"], all$type[all$entrain=="yes"]))
```

There is a similar number of divergence and convergence effects. But there was almost no synchrony and a lot of dyssynchrony.

```{r}
table(all$direction[all$entrain=="yes"])
```

There was roughly the same number of effects on each feature.

```{r}
table(all$feature[all$entrain=="yes"])
table(paste(all$feature[all$entrain=="yes"], all$direction[all$direction!="dyssynchrony" & all$entrain=="yes"]))
```

When a given speaker shows an effect, they more likely also show other effects.

```{r}
sort(table(all$speaker[all$entrain=="yes"]))
hist(table(all$speaker[all$entrain=="yes"]))
```

# Exploring relationships between effects above and other variables

## Temperature change

### Convergence

There doesn't seem to be a relationship between significant temperature change and a participant's tendency to converge or diverge from their partner. (Looking at the data set itself, there also doesn't seem to be any patterns.)

```{r}
load(paste0(here::here(), "/data/individualTemp.RData"))
t1 <- indTemp |> 
  filter(section=="entireExp") |> 
  group_by(speaker) |>
  pivot_wider(names_from = ROI, values_from = effect, id_cols=speaker) |> 
  mutate(section = "entireExp")

t2 <- indTemp |> 
  filter(section=="Lists") |> 
  group_by(speaker) |>
  pivot_wider(names_from = ROI, values_from = effect, id_cols=speaker) |> 
  mutate(section = "Lists")

t3 <- indTemp |> 
  filter(section=="Diapix") |> 
  group_by(speaker) |>
  pivot_wider(names_from = ROI, values_from = effect, id_cols=speaker) |> 
  mutate(section = "Diapix")
# mutate(section = "Lists") # naming the Diapix section and "Lists" to pair these values with the f0 adaptation during "Lists", since temperature change takes a while to happen
# this also didn't bring about any new insights

t <- rbind(t1, rbind(t2, t3))
# t <- rbind(t1, t3)

dat <- merge(t,
             all |> 
               filter(type == "convergence") |> 
               select(speaker, direction, entrain, condition, feature, section),
             by=c("speaker", "section"), all=TRUE) |> 
  mutate(conv = case_when(
    entrain == "no" ~ "ns",
    entrain == "yes" ~ direction
  )) |> 
  mutate_all(as.factor)

dat$Forehead <- relevel(dat$Forehead, ref="ns")
dat$Cheeks <- relevel(dat$Cheeks, ref="ns")
dat$Eyes <- relevel(dat$Eyes, ref="ns")
dat$Nose <- relevel(dat$Nose, ref="ns")
dat$conv <- relevel(dat$conv, ref="ns")
```

```{r}
ggplot(dat |> drop_na(), aes(Forehead, fill=conv))+
  geom_bar()+
  ggtitle("Forehead")+
  scale_fill_manual(values = c("divergence" = "lightblue", "convergence" = "red", "ns" = "gray"))
```

```{r}
tidy(m <- nnet::multinom(Forehead ~ conv, data=dat)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
```

```{r}
ggplot(dat |> drop_na(), aes(Cheeks, fill=conv))+
  geom_bar()+
  ggtitle("Cheeks")+
  scale_fill_manual(values = c("divergence" = "lightblue", "convergence" = "red", "ns" = "gray"))
```

```{r}
tidy(m <- nnet::multinom(Cheeks ~ conv, data=dat)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
```

```{r}
ggplot(dat |> drop_na(), aes(Eyes, fill=conv))+
  geom_bar()+
  ggtitle("Eyes")+
  scale_fill_manual(values = c("divergence" = "lightblue", "convergence" = "red", "ns" = "gray"))
```

```{r}
tidy(m <- nnet::multinom(Eyes ~ conv, data=dat)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
```

```{r}
ggplot(dat |> drop_na(), aes(Nose, fill=conv))+
  geom_bar()+
  ggtitle("Nose")+
  scale_fill_manual(values = c("divergence" = "lightblue", "convergence" = "red", "ns" = "gray"))
```

```{r}
tidy(m <- nnet::multinom(Nose ~ conv, data=dat)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
```

### Synchrony

Also for synchrony, there doesn't seem to be a relationship between temperature change and tendency to (dys)synchronize.

```{r}
dat <- merge(t,
             all |> 
               filter(type == "synchrony") |> 
               select(speaker, direction, entrain, condition, feature, section),
             by=c("speaker", "section"), all=TRUE) |> 
  mutate(syn = case_when(
    entrain == "no" ~ "ns",
    entrain == "yes" ~ direction
  )) |> 
  mutate_all(as.factor)

dat$Forehead <- relevel(dat$Forehead, ref="ns")
dat$Cheeks <- relevel(dat$Cheeks, ref="ns")
dat$Eyes <- relevel(dat$Eyes, ref="ns")
dat$Nose <- relevel(dat$Nose, ref="ns")
dat$syn <- relevel(dat$syn, ref="ns")
```

```{r}
ggplot(dat |> drop_na(), aes(Forehead, fill=syn))+
  geom_bar()+
  ggtitle("Forehead")+
  scale_fill_manual(values = c("dyssynchrony" = "lightblue", "synchrony" = "red", "ns" = "gray"))
```

```{r}
tidy(m <- nnet::multinom(Forehead ~ syn, data=dat)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
```

```{r}
ggplot(dat |> drop_na(), aes(Cheeks, fill=syn))+
  geom_bar()+
  ggtitle("Cheeks")+
  scale_fill_manual(values = c("dyssynchrony" = "lightblue", "synchrony" = "red", "ns" = "gray"))
```

```{r}
tidy(m <- nnet::multinom(Cheeks ~ syn, data=dat)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
```

```{r}
ggplot(dat |> drop_na(), aes(Eyes, fill=syn))+
  geom_bar()+
  ggtitle("Eyes")+
  scale_fill_manual(values = c("dyssynchrony" = "lightblue", "synchrony" = "red", "ns" = "gray"))
```

```{r}
tidy(m <- nnet::multinom(Eyes ~ syn, data=dat)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
```

```{r}
ggplot(dat |> drop_na(), aes(Nose, fill=syn))+
  geom_bar()+
  ggtitle("Nose")+
  scale_fill_manual(values = c("dyssynchrony" = "lightblue", "synchrony" = "red", "ns" = "gray"))
```

```{r}
tidy(m <- nnet::multinom(Nose ~ syn, data=dat)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
```

## Questionnaire scores

### Using regression coefficient

```{r}
d <- merge(all |> filter(type == "convergence") |> select(-condition),
           meta,
           by="speaker", all=TRUE) |> 
  # mutate(entrain = ifelse(is.na(entrain), "no", entrain),
  #        direction = ifelse(is.na(direction), "no", direction),
  #        type = ifelse(is.na(type), "convergence", type)) |> 
  mutate(effect = case_when(
    entrain == "no" ~ "ns",
    entrain == "yes" ~ direction
  )) |> 
  mutate_at(c("entrain", "direction", "type", "effect"), as.factor) |> 
  mutate_at(c("coefficient"), as.numeric)
d$effect <- relevel(d$effect, ref="ns")
```

No effect of condition.

```{r}
summary(lmer(coefficient ~ condition + (1|speaker), d))
```

No effect of speakers' perception of their partner. (It was the same null result if I used `d |> filter(entrain=="yes")`, and also if we look at each section separately.)

```{r}
summary(lmer(coefficient ~ closeness + (1|speaker), d))
summary(lmer(coefficient ~ similarity + (1|speaker), d))
summary(lmer(coefficient ~ likeability + (1|speaker), d))
summary(lmer(coefficient ~ becomeFriends + (1|speaker), d))

# summary(lmer(coefficient ~ closeness + (1|speaker), d |> filter(section=="Lists")))
# summary(lmer(coefficient ~ similarity + (1|speaker), d |> filter(section=="Lists")))
# summary(lmer(coefficient ~ likeability + (1|speaker), d |> filter(section=="Lists")))
# summary(lmer(coefficient ~ becomeFriends + (1|speaker), d |> filter(section=="Lists")))
# 
# summary(lmer(coefficient ~ closeness + (1|speaker), d |> filter(section=="Diapix")))
# summary(lmer(coefficient ~ similarity + (1|speaker), d |> filter(section=="Diapix")))
# summary(lmer(coefficient ~ likeability + (1|speaker), d |> filter(section=="Diapix")))
# summary(lmer(coefficient ~ becomeFriends + (1|speaker), d |> filter(section=="Diapix")))
# 
# summary(lmer(coefficient ~ closeness + (1|speaker), d |> filter(section=="entireExp")))
# summary(lmer(coefficient ~ similarity + (1|speaker), d |> filter(section=="entireExp")))
# summary(lmer(coefficient ~ likeability + (1|speaker), d |> filter(section=="entireExp")))
# summary(lmer(coefficient ~ becomeFriends + (1|speaker), d |> filter(section=="entireExp")))
```

No effect of speakers' perception of BFI scores.

```{r}
summary(lmer(coefficient ~ extraversion + (1|speaker), d))
summary(lmer(coefficient ~ openness + (1|speaker), d))
summary(lmer(coefficient ~ agreeableness + (1|speaker), d))
summary(lmer(coefficient ~ conscientiousness + (1|speaker), d))
summary(lmer(coefficient ~ neuroticism + (1|speaker), d))
```

### Using yes/no labels

#### Convergence

```{r}
d <- merge(all |> filter(type == "convergence") |> select(-condition),
           meta,
           by="speaker", all=TRUE) |> 
  # mutate(entrain = ifelse(is.na(entrain), "no", entrain),
  #        direction = ifelse(is.na(direction), "no", direction),
  #        type = ifelse(is.na(type), "convergence", type)) |> 
  mutate(effect = case_when(
    entrain == "no" ~ "ns",
    entrain == "yes" ~ direction
  )) |> 
  mutate_at(c("entrain", "direction", "type", "effect"), as.factor)
d$effect <- relevel(d$effect, ref="ns")
```

Condition: no effect

```{r}
summary(glmer(entrain ~ condition + (1|speaker), d, family=binomial))
```

Scores on questionnaire about perception of partner: no effect. Also no effect when we take each section separately.

```{r}
summary(glmer(entrain ~ closeness + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ similarity + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ likeability + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ becomeFriends + (1|speaker), d, family=binomial))

# summary(glmer(entrain ~ closeness + (1|speaker), d |> filter(section=="Lists"), family=binomial))
# summary(glmer(entrain ~ similarity + (1|speaker), d |> filter(section=="Lists"), family=binomial))
# summary(glmer(entrain ~ likeability + (1|speaker), d |> filter(section=="Lists"), family=binomial))
# summary(glmer(entrain ~ becomeFriends + (1|speaker), d |> filter(section=="Lists"), family=binomial))
# 
# summary(glmer(entrain ~ closeness + (1|speaker), d |> filter(section=="Diapix"), family=binomial))
# summary(glmer(entrain ~ similarity + (1|speaker), d |> filter(section=="Diapix"), family=binomial))
# summary(glmer(entrain ~ likeability + (1|speaker), d |> filter(section=="Diapix"), family=binomial))
# summary(glmer(entrain ~ becomeFriends + (1|speaker), d |> filter(section=="Diapix"), family=binomial))
```

BFI scores: no effect, BUT openness, agreeableness, neuroticism not converging.

```{r}
summary(glmer(entrain ~ extraversion + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ openness + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ agreeableness + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ conscientiousness + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ neuroticism + (1|speaker), d, family=binomial))
```

##### Direction of the effect (convergence vs divergence)

Condition: no effect

```{r}
tidy(m <- nnet::multinom(effect ~ condition, data=d)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

No effect of perception of partner

```{r}
tidy(m <- nnet::multinom(effect ~ closeness, data=d)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(effect ~ similarity, data=d)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(effect ~ likeability, data=d)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(effect ~ becomeFriends, data=d)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

BFI scores: no effects

```{r}
tidy(m <- nnet::multinom(effect ~ extraversion, data=d)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(effect ~ openness, data=d)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(effect ~ agreeableness, data=d)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(effect ~ conscientiousness, data=d)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))

tidy(m <- nnet::multinom(effect ~ neuroticism, data=d)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate))
```

#### Synchrony

```{r}
d <- merge(all |> filter(type == "synchrony") |> select(-condition),
           meta,
           by="speaker", all=TRUE) |> 
  # mutate(entrain = ifelse(is.na(entrain), "no", entrain),
  #        direction = ifelse(is.na(direction), "no", direction),
  #        type = ifelse(is.na(type), "synchrony", type)) |> 
  mutate(effect = case_when(
    entrain == "no" ~ "ns",
    entrain == "yes" ~ direction
  )) |> 
  mutate_at(c("entrain", "direction", "type", "effect"), as.factor) 
```

No effect of condition on dyssynchrony.

```{r}
summary(glmer(entrain ~ condition + (1|speaker), d, family=binomial))
```

No effect of perception of partner.

```{r}
summary(glmer(entrain ~ closeness + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ similarity + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ likeability + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ becomeFriends + (1|speaker), d, family=binomial))
```

No effect of BFI scores.

```{r}
summary(glmer(entrain ~ extraversion + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ openness + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ agreeableness + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ conscientiousness + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ neuroticism + (1|speaker), d, family=binomial))
```

(It doesn't make sense to analyze the direction of the effect here---snychrony vs. dyssynchrony---because there were almost no synchrony effects.)

(I also wanted to link the temperature and speech datasets to analyze them in relation to each other. But there are so few speech data points with significant entrainment, that it doesn't make sense to make this analysis.)

# Session Info

```{r}
sessionInfo()
```
