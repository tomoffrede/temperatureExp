---
title: "Analysis-Speech"
author: "Tom Offrede"
output:
  html_document:
    toc: true
    toc_float: 
      collapsed: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
library(tidyverse)
library(lmerTest)
library(DHARMa)
library(broom)
library(parsnip)

load(paste0(here::here(), "/data/speechData.RData"))
load(paste0(here::here(), "/data/speechData-allIPUs.RData"))
load(paste0(here::here(), "/data/metadata-clean.RData"))
load(paste0(here::here(), "/data/individualTemp.RData"))
meta <- m
badFiles <- c(paste0("AML-D", c(1, 2)), paste0("FWR-L", c(1, 2, 3)), paste0("HAG-D", c(1, 2)), paste0("HBR-D", c(1, 2)), paste0("HBR-L", c(1, 2, 3)), paste0("HUJ-D", c(1, 2)), "KPB-D1", paste0("MJG-D", c(1, 2)), paste0("MJG-L", c(1, 2)), "OAL-D1", paste0("OAL-L", c(1, 2, 3)), paste0("OXQ-D", c(1, 2)), paste0("OXQ-L", c(1, 2, 3)), "SGB-D1", paste0("SGB-L", c(1, 2, 3)), paste0("SUK-D", c(1, 2)), "TTN-D1", paste0("TTN-L", c(1, 2, 3)), "TTY-D1", paste0("VDE-D", c(1, 2)), "ZNV-D1")
```

# Summary of results

* Some participants entrained and some didn't; sometimes only in the first part of the experiment, sometimes in the second, sometimes across it all.
* The most common effect was of dyssynchrony, meaning the participants often produce different f0 from the previous turn's last IPU. Makes sense: question-answer.
* I didn't find any effects of condition.

# Notes

* The check of residuals of logistic models below, was done following: https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html


# Individual change -- regardless of interlocutor

## f0 median

* Analysis across entire experiment: f0 median goes up only in *close* condition.
* Analysis only during question lists: f0 median doesn't change in any group.
* Analysis only during Diapix: f0 median goes up only in the *impersonal* condition.

(This was the same regardless of whether males were included.)

```{r}
load(paste0(here::here(), "/data/speechData-allIPUs.RData"))
# ipus <- ipus |> 
#   filter(gender != "Male")
```

```{r}
ggplot(ipus, aes(turn, f0med))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)
summary(lmer(f0med ~ turn : condition + (1|speaker), ipus))

ggplot(ipus |> filter(task=="Lists"), aes(turn, f0med))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)
summary(lmer(f0med ~ turn : condition + (1|speaker), ipus |> filter(task=="Lists")))

ggplot(ipus |> filter(task=="Diapix"), aes(turn, f0med))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)
summary(lmer(f0med ~ turn : condition + (1|speaker), ipus |> filter(task=="Diapix")))
```

Checking if f0 median changes across time in interaction with questionnaire scores:
* Even though all the models are significant, their AIC is not preferred over the model without the questionnaire scores.
```{r}
summary(m <- lmer(f0med ~ turn + (1|speaker), ipus))
summary(m1 <- lmer(f0med ~ turn : closeness + (1|speaker), ipus))
summary(m2 <- lmer(f0med ~ turn : similarity + (1|speaker), ipus))
summary(m3 <- lmer(f0med ~ turn : likeability + (1|speaker), ipus))
summary(m4 <- lmer(f0med ~ turn : becomeFriends + (1|speaker), ipus))

anova(m, m1)
anova(m, m2)
anova(m, m3)
anova(m, m4)
```


## f0 max

* Analysis across entire experiment: f0 max goes down in both conditions (though this isn't clear in the graph...)
* Analysis only during question lists: f0 max goes down only in the *impersonal* condition.
* Analysis only during Diapix: f0 max goes down only in the *impersonal* condition (though again, the graph seems to suggest the opposite...).

(This was the same regardless of whether males were included.)

```{r}
load(paste0(here::here(), "/data/speechData-allIPUs.RData"))
# ipus <- ipus |>
#   filter(gender != "Male")
```

```{r}
ggplot(ipus, aes(turn, f0max))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)
summary(lmer(f0max ~ turn : condition + (1|speaker), ipus))

ggplot(ipus |> filter(task=="Lists"), aes(turn, f0max))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)
summary(lmer(f0max ~ turn : condition + (1|speaker), ipus |> filter(task=="Lists")))

ggplot(ipus |> filter(task=="Diapix"), aes(turn, f0max))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)
summary(lmer(f0max ~ turn : condition + (1|speaker), ipus |> filter(task=="Diapix")))
```

Checking if f0 SD changes across time in interaction with questionnaire scores:
* Even though all the models are significant, their AIC is not preferred over the model without the questionnaire scores.
```{r}
summary(m <- lmer(f0max ~ turn + (1|speaker), ipus))
summary(m1 <- lmer(f0max ~ turn : closeness + (1|speaker), ipus))
summary(m2 <- lmer(f0max ~ turn : similarity + (1|speaker), ipus))
summary(m3 <- lmer(f0max ~ turn : likeability + (1|speaker), ipus))
summary(m4 <- lmer(f0max ~ turn : becomeFriends + (1|speaker), ipus))

anova(m, m1)
anova(m, m2)
anova(m, m3)
anova(m, m4)
```

## f0 SD

* Analysis across entire experiment: f0 SD goes down in the *impersonal* condition (though this isn't clear in the graph...)
* Analysis only during question lists: f0 SD goes down only in the *close* condition.
* Analysis only during Diapix: f0 SD goes down in both conditions.

This is weird... if SD went down in the close condition when taking each section separately, why does it not changing when taking the entire experiment?

(This was the same regardless of whether males were included.)

```{r}
load(paste0(here::here(), "/data/speechData-allIPUs.RData"))
# ipus <- ipus |>
#   filter(gender != "Male")
```

```{r}
ggplot(ipus, aes(turn, f0sd))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)
summary(lmer(f0sd ~ turn : condition + (1|speaker), ipus))

ggplot(ipus |> filter(task=="Lists"), aes(turn, f0sd))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)
summary(lmer(f0sd ~ turn : condition + (1|speaker), ipus |> filter(task=="Lists")))

ggplot(ipus |> filter(task=="Diapix"), aes(turn, f0sd))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~condition)
summary(lmer(f0sd ~ turn : condition + (1|speaker), ipus |> filter(task=="Diapix")))
```

Checking if f0 SD changes across time in interaction with questionnaire scores:
* Speakers that felt more *similar* to their partner tended to decrease their f0 SD *more* across the experiment.
```{r}
summary(m <- lmer(f0sd ~ turn + (1|speaker), ipus))
summary(m1 <- lmer(f0sd ~ turn : closeness + (1|speaker), ipus))
summary(m2 <- lmer(f0sd ~ turn : similarity + (1|speaker), ipus))
summary(m3 <- lmer(f0sd ~ turn : likeability + (1|speaker), ipus))
summary(m4 <- lmer(f0sd ~ turn : becomeFriends + (1|speaker), ipus))

anova(m, m1)
anova(m, m2)
anova(m, m3)
anova(m, m4)
```


# Local convergence
(following Levitan & Hirschberg 2011's method)

```{r}
all <- data.frame(matrix(nrow=0, ncol=9))
names(all) <- c("speaker", "type", "direction", "coefficient", "mock", "real", "condition", "feature", "section")
```


## f0 median

### Across the entire experiment

```{r}
ggplot(dat, aes(turnOverall, f0medDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0medDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMedDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "entireExp",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the only 3 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged and two diverged on f0 median. All from the impersonal condition.

```{r}
print(count)
```


### Only in the first part of the experiment
Since we could argue that the speakers converge to each other only in the beginning, and that in the second part of the experiment the difference between f0s doesn't keep decreasing (or increasing)

```{r}
ggplot(dat |> filter(task=="Lists"), aes(turnOverall, f0medDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0medDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMedDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "Lists",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the only 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged (in the close condition) and one diverged (impersonal condition) on f0 median.
These 2 are different from the 3 displayed above.

```{r}
print(count)
```


### Only in the second part of the experiment
Since we could argue that the speakers converge to each other more in the second part of the experiment, after they already got to know each other (and like each other or not) in the first part.

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(turnOverall, f0medDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0medDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMedDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "Diapix",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the only speaker whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

She was in the close condition and converged to her partner.

```{r}
print(count)
```


## f0 max

### Across the entire experiment

```{r}
ggplot(dat, aes(turnOverall, f0maxDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0maxDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMaxDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "entireExp",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

No one seemed to converge or diverge on f0 max.

```{r}
print(count)
```


### Only in the first part of the experiment
Since we could argue that the speakers converge to each other only in the beginning, and that in the second part of the experiment the difference between f0s doesn't keep decreasing (or increasing)

```{r}
ggplot(dat |> filter(task=="Lists"), aes(turnOverall, f0maxDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0maxDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMaxDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "Lists",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the only 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged (in the close condition) and one diverged (impersonal condition) on f0 max.

```{r}
print(count)
```


### Only in the second part of the experiment
Since we could argue that the speakers converge to each other more in the second part of the experiment, after they already got to know each other (and like each other or not) in the first part.

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(turnOverall, f0maxDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0maxDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMaxDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "Diapix",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the only 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One diverged and one converged on f0 max. Both were in the impersonal condition.

```{r}
print(count)
```

## f0 SD

### Across the entire experiment

```{r}
ggplot(dat, aes(turnOverall, f0sdDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0sdDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSdDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "entireExp",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

No one seemed to converge or diverge on f0 sd.

```{r}
print(count)
```


### Only in the first part of the experiment
Since we could argue that the speakers converge to each other only in the beginning, and that in the second part of the experiment the difference between f0s doesn't keep decreasing (or increasing)

```{r}
ggplot(dat |> filter(task=="Lists"), aes(turnOverall, f0sdDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0sdDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSdDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "Lists",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the only 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged (in the impersonal condition) and one diverged (close condition) on f0 sd.

```{r}
print(count)
```


### Only in the second part of the experiment
Since we could argue that the speakers converge to each other more in the second part of the experiment, after they already got to know each other (and like each other or not) in the first part.

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(turnOverall, f0sdDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0sdDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSdDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "Diapix",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the only 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged (in the impersonal condition) and one diverged (close condition) on f0 sd.

```{r}
print(count)
```

# Local Synchrony

## f0 median

### Across the entire experiment

```{r}
ggplot(dat, aes(f0med, prevf0med))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0med, d$prevf0med,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMed", i)], d$f0med,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "entireExp",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the 4 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged (impersonal condition) and three diverged (2 in impersonal and 1 in close condition.)

```{r}
print(count)
```

### Only in the first part of the experiment

```{r}
ggplot(dat |> filter(task=="Lists"), aes(f0med, prevf0med))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0med, d$prevf0med,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMed", i)], d$f0med,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "Lists",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the 4 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One in the close condition synchronized and two in the close condition desynchronized. One in the impersonal condition desynchronized.

```{r}
print(count)
```

### Only in the second part of the experiment

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(f0med, prevf0med))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0med, d$prevf0med,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMed", i)], d$f0med,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "Diapix",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the 3 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

All three desynchronized. One in the close condition and two in the impersonal condition.

```{r}
print(count)
```

## f0 max

### Across the entire experiment

```{r}
ggplot(dat, aes(f0max, prevf0max))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0max, d$prevf0max,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMax", i)], d$f0max,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "entireExp",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the 8 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

All desynchronized. Two in the close condition and six in the impersonal condition.

```{r}
print(count)
```

### Only in the first part of the experiment

```{r}
ggplot(dat |> filter(task=="Lists"), aes(f0max, prevf0max))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0max, d$prevf0max,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMax", i)], d$f0max,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "Lists",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the only speaker whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

She was in the impersonal condition and desynchronized.

```{r}
print(count)
```

### Only in the second part of the experiment

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(f0max, prevf0max))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0max, d$prevf0max,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMax", i)], d$f0max,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "Diapix",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the 3 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

All desynchronized, one in the close and two in the impersonal condition.

```{r}
print(count)
```

## f0 SD

### Across the entire experiment

```{r}
ggplot(dat, aes(f0sd, prevf0sd))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0sd, d$prevf0sd,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSd", i)], d$f0sd,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "entireExp",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the 5 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One synchronized (close condition). Four desynchronized (two close and two impersonal condition).

```{r}
print(count)
```

### Only in the first part of the experiment

```{r}
ggplot(dat |> filter(task=="Lists"), aes(f0sd, prevf0sd))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0sd, d$prevf0sd,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSd", i)], d$f0sd,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "Lists",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

Both desynchronized and were in the close condition.

```{r}
print(count)
```

### Only in the second part of the experiment

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(f0sd, prevf0sd))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0sd, d$prevf0sd,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSd", i)], d$f0sd,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=6))
names(count) <- c("speaker", "type", "direction", "coefficient", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             corS$r[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "Diapix",
         real = case_when(
           mock > 1 | is.na(real) ~ "no",
           .default = as.character(real)
         ))

all <- rbind(all, count)
```

Below we see the 4 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

All desynchronized -- two in the close and two in the impersonal condition.

```{r}
print(count)
```

# All effects

```{r}
all <- all |> 
  mutate(sectionN = case_when(
    section=="entireExp" ~ 1,
    section=="Lists" ~ 2,
    section=="Diapix" ~ 3
  )) |> 
  rename(entrain=real) |> 
  arrange(sectionN) |> 
  select(-sectionN)
print(all |> filter(entrain=="yes"))
```

Most effects were when we take the entire experiment. But a considerable number of effects in each section too.
(Note: the higher number of effects across the whole experiment should *not* be because of the increased number of datapoints, since we do a robustness check with 10 pseudo-datapoints to control for number of points.)
```{r}
table(all$section[all$entrain=="yes"])
table(paste(all$section[all$entrain=="yes"], all$type[all$entrain=="yes"]))
```

There is a similar number of divergence and convergence effects. But there was almost no synchrony and a lot of dyssynchrony.
```{r}
table(all$direction[all$entrain=="yes"])
```

There was roughly the same number of effects on each feature.
```{r}
table(all$feature[all$entrain=="yes"])
table(paste(all$feature[all$entrain=="yes"], all$direction[all$direction!="dyssynchrony" & all$entrain=="yes"]))
```

When a given speaker shows an effect, they more likely also show other effects.
```{r}
sort(table(all$speaker[all$entrain=="yes"]))
hist(table(all$speaker[all$entrain=="yes"]))
```

# Exploring relationships between effects above and other variables

## Temperature change

### Convergence

There doesn't seem to be a relationship between significant temperature change and a participant's tendency to converge or diverge from their partner.
(Looking at the data set itself, there also doesn't seem to be any patterns.)

```{r}
t1 <- indTemp |> 
  filter(section=="entireExp") |> 
  group_by(speaker) |>
  pivot_wider(names_from = ROI, values_from = effect, id_cols=speaker) |> 
  mutate(section = "entireExp")

t2 <- indTemp |> 
  filter(section=="Lists") |> 
  group_by(speaker) |>
  pivot_wider(names_from = ROI, values_from = effect, id_cols=speaker) |> 
  mutate(section = "Lists")

t3 <- indTemp |> 
  filter(section=="Diapix") |> 
  group_by(speaker) |>
  pivot_wider(names_from = ROI, values_from = effect, id_cols=speaker) |> 
  mutate(section = "Diapix")

t <- rbind(t1, rbind(t2, t3))

dat <- merge(t,
             all |> 
               filter(type == "convergence") |> 
               select(speaker, direction, entrain, condition, feature, section),
             by=c("speaker", "section"), all=TRUE) |> 
  mutate(conv = case_when(
    entrain == "no" ~ "ns",
    entrain == "yes" ~ direction
  )) |> 
  mutate_all(as.factor)

dat$Forehead <- relevel(dat$Forehead, ref="ns")
dat$Cheeks <- relevel(dat$Cheeks, ref="ns")
dat$Eyes <- relevel(dat$Eyes, ref="ns")
dat$Nose <- relevel(dat$Nose, ref="ns")
dat$conv <- relevel(dat$conv, ref="ns")
```

```{r}
ggplot(dat |> drop_na(), aes(Forehead, fill=conv))+
  geom_bar()+
  ggtitle("Forehead")+
  scale_fill_manual(values = c("divergence" = "lightblue", "convergence" = "red", "ns" = "gray"))
```

```{r}
tidy(m <- nnet::multinom(Forehead ~ conv, data=dat)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
```

```{r}
ggplot(dat |> drop_na(), aes(Cheeks, fill=conv))+
  geom_bar()+
  ggtitle("Cheeks")+
  scale_fill_manual(values = c("divergence" = "lightblue", "convergence" = "red", "ns" = "gray"))
```

```{r}
tidy(m <- nnet::multinom(Cheeks ~ conv, data=dat)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
```

```{r}
ggplot(dat |> drop_na(), aes(Eyes, fill=conv))+
  geom_bar()+
  ggtitle("Eyes")+
  scale_fill_manual(values = c("divergence" = "lightblue", "convergence" = "red", "ns" = "gray"))
```

```{r}
tidy(m <- nnet::multinom(Eyes ~ conv, data=dat)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
```

```{r}
ggplot(dat |> drop_na(), aes(Nose, fill=conv))+
  geom_bar()+
  ggtitle("Nose")+
  scale_fill_manual(values = c("divergence" = "lightblue", "convergence" = "red", "ns" = "gray"))
```

```{r}
tidy(m <- nnet::multinom(Nose ~ conv, data=dat)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
```

### Synchrony

Also for synchrony, there doesn't seem to be a relationship between temperature change and tendency to (dys)synchronize.

```{r}
dat <- merge(t,
             all |> 
               filter(type == "synchrony") |> 
               select(speaker, direction, entrain, condition, feature, section),
             by=c("speaker", "section"), all=TRUE) |> 
  mutate(syn = case_when(
    entrain == "no" ~ "ns",
    entrain == "yes" ~ direction
  )) |> 
  mutate_all(as.factor)

dat$Forehead <- relevel(dat$Forehead, ref="ns")
dat$Cheeks <- relevel(dat$Cheeks, ref="ns")
dat$Eyes <- relevel(dat$Eyes, ref="ns")
dat$Nose <- relevel(dat$Nose, ref="ns")
dat$syn <- relevel(dat$syn, ref="ns")
```

```{r}
ggplot(dat |> drop_na(), aes(Forehead, fill=syn))+
  geom_bar()+
  ggtitle("Forehead")+
  scale_fill_manual(values = c("dyssynchrony" = "lightblue", "synchrony" = "red", "ns" = "gray"))
```

```{r}
tidy(m <- nnet::multinom(Forehead ~ syn, data=dat)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
```

```{r}
ggplot(dat |> drop_na(), aes(Cheeks, fill=syn))+
  geom_bar()+
  ggtitle("Cheeks")+
  scale_fill_manual(values = c("dyssynchrony" = "lightblue", "synchrony" = "red", "ns" = "gray"))
```

```{r}
tidy(m <- nnet::multinom(Cheeks ~ syn, data=dat)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
```

```{r}
ggplot(dat |> drop_na(), aes(Eyes, fill=syn))+
  geom_bar()+
  ggtitle("Eyes")+
  scale_fill_manual(values = c("dyssynchrony" = "lightblue", "synchrony" = "red", "ns" = "gray"))
```

```{r}
tidy(m <- nnet::multinom(Eyes ~ syn, data=dat)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
```

```{r}
ggplot(dat |> drop_na(), aes(Nose, fill=syn))+
  geom_bar()+
  ggtitle("Nose")+
  scale_fill_manual(values = c("dyssynchrony" = "lightblue", "synchrony" = "red", "ns" = "gray"))
```

```{r}
tidy(m <- nnet::multinom(Nose ~ syn, data=dat)) |> 
  as_tibble() |> 
  mutate(estimate = plogis(estimate)) # plogis transforms log odds (the output of the model) into probabilities
```

## Questionnaire scores

### Using regression coefficient

```{r}
d <- merge(all |> filter(type == "convergence") |> select(-condition),
           meta,
           by="speaker", all=TRUE) |> 
  # mutate(entrain = ifelse(is.na(entrain), "no", entrain),
  #        direction = ifelse(is.na(direction), "no", direction),
  #        type = ifelse(is.na(type), "convergence", type)) |> 
  mutate_at(c("entrain", "direction", "type"), as.factor) |> 
  mutate_at(c("coefficient"), as.numeric)
```

No effect of condition.
```{r}
summary(lmer(coefficient ~ condition + (1|speaker), d))
```

No effect of speakers' perception of their partner. (It was the same null result if I used `d |> filter(entrain=="yes")`, and also if we look at each section separately.)
```{r}
summary(lmer(coefficient ~ closeness + (1|speaker), d))
summary(lmer(coefficient ~ similarity + (1|speaker), d))
summary(lmer(coefficient ~ likeability + (1|speaker), d))
summary(lmer(coefficient ~ becomeFriends + (1|speaker), d))

# summary(lmer(coefficient ~ closeness + (1|speaker), d |> filter(section=="Lists")))
# summary(lmer(coefficient ~ similarity + (1|speaker), d |> filter(section=="Lists")))
# summary(lmer(coefficient ~ likeability + (1|speaker), d |> filter(section=="Lists")))
# summary(lmer(coefficient ~ becomeFriends + (1|speaker), d |> filter(section=="Lists")))
# 
# summary(lmer(coefficient ~ closeness + (1|speaker), d |> filter(section=="Diapix")))
# summary(lmer(coefficient ~ similarity + (1|speaker), d |> filter(section=="Diapix")))
# summary(lmer(coefficient ~ likeability + (1|speaker), d |> filter(section=="Diapix")))
# summary(lmer(coefficient ~ becomeFriends + (1|speaker), d |> filter(section=="Diapix")))
# 
# summary(lmer(coefficient ~ closeness + (1|speaker), d |> filter(section=="entireExp")))
# summary(lmer(coefficient ~ similarity + (1|speaker), d |> filter(section=="entireExp")))
# summary(lmer(coefficient ~ likeability + (1|speaker), d |> filter(section=="entireExp")))
# summary(lmer(coefficient ~ becomeFriends + (1|speaker), d |> filter(section=="entireExp")))
```

No effect of speakers' perception of BFI scores.
```{r}
summary(lmer(coefficient ~ extraversion + (1|speaker), d))
summary(lmer(coefficient ~ openness + (1|speaker), d))
summary(lmer(coefficient ~ agreeableness + (1|speaker), d))
summary(lmer(coefficient ~ conscientiousness + (1|speaker), d))
summary(lmer(coefficient ~ neuroticism + (1|speaker), d))
```

### Using yes/no labels

#### Convergence

```{r}
d <- merge(all |> filter(type == "convergence") |> select(-condition),
           meta,
           by="speaker", all=TRUE) |> 
  # mutate(entrain = ifelse(is.na(entrain), "no", entrain),
  #        direction = ifelse(is.na(direction), "no", direction),
  #        type = ifelse(is.na(type), "convergence", type)) |> 
  mutate_at(c("entrain", "direction", "type"), as.factor)
# d$direction <- relevel(d$direction, ref="no")
```

Condition: no effect
```{r}
summary(glmer(entrain ~ condition + (1|speaker), d, family=binomial))
```

Scores on questionnaire about perception of partner: no effect.
Also no effect when we take each section separately.
```{r}
summary(glmer(entrain ~ closeness + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ similarity + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ likeability + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ becomeFriends + (1|speaker), d, family=binomial))

# summary(glmer(entrain ~ closeness + (1|speaker), d |> filter(section=="Lists"), family=binomial))
# summary(glmer(entrain ~ similarity + (1|speaker), d |> filter(section=="Lists"), family=binomial))
# summary(glmer(entrain ~ likeability + (1|speaker), d |> filter(section=="Lists"), family=binomial))
# summary(glmer(entrain ~ becomeFriends + (1|speaker), d |> filter(section=="Lists"), family=binomial))
# 
# summary(glmer(entrain ~ closeness + (1|speaker), d |> filter(section=="Diapix"), family=binomial))
# summary(glmer(entrain ~ similarity + (1|speaker), d |> filter(section=="Diapix"), family=binomial))
# summary(glmer(entrain ~ likeability + (1|speaker), d |> filter(section=="Diapix"), family=binomial))
# summary(glmer(entrain ~ becomeFriends + (1|speaker), d |> filter(section=="Diapix"), family=binomial))
```

BFI scores: no effect, BUT openness, agreeableness, neuroticism not converging.
```{r}
summary(glmer(entrain ~ extraversion + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ openness + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ agreeableness + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ conscientiousness + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ neuroticism + (1|speaker), d, family=binomial))
```

##### Direction of the effect (convergence vs divergence)

Condition: no effect
```{r}
m <- multinom_reg() |> 
  fit(direction ~ condition, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)
```

Questionnaire scores:
* Speakers seem to do more divergence than convergence when they feel *closer* to their partner.
* The regression suggests people converged more when they felt more similar, but the plot shows no difference.

```{r}
ggplot(d, aes(direction, closeness))+
  geom_boxplot()+
  ggtitle("Direction of convergence and closeness feeling")

ggplot(d, aes(direction, similarity))+
  geom_boxplot()+
  ggtitle("Direction of convergence and similarity feeling")
```


```{r}
m <- multinom_reg() |> 
  fit(direction ~ closeness, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)

m <- multinom_reg() |> 
  fit(direction ~ similarity, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)

m <- multinom_reg() |> 
  fit(direction ~ likeability, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)

m <- multinom_reg() |> 
  fit(direction ~ becomeFriends, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)
```

BFI scores: no effects
```{r}
m <- multinom_reg() |> 
  fit(direction ~ extraversion, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)

m <- multinom_reg() |> 
  fit(direction ~ openness, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)

m <- multinom_reg() |> 
  fit(direction ~ agreeableness, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)

m <- multinom_reg() |> 
  fit(direction ~ conscientiousness, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)

m <- multinom_reg() |> 
  fit(direction ~ neuroticism, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)
```

#### Synchrony

```{r}
d <- merge(all |> filter(type == "synchrony") |> select(-condition),
           meta,
           by="speaker", all=TRUE) |> 
  # mutate(entrain = ifelse(is.na(entrain), "no", entrain),
  #        direction = ifelse(is.na(direction), "no", direction),
  #        type = ifelse(is.na(type), "synchrony", type)) |> 
  mutate_at(c("entrain", "direction", "type"), as.factor) 
```


No effect of condition on dyssynchrony.
```{r}
summary(glmer(entrain ~ condition + (1|speaker), d, family=binomial))
```

No effect of perception of partner.
```{r}
summary(glmer(entrain ~ closeness + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ similarity + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ likeability + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ becomeFriends + (1|speaker), d, family=binomial))
```

No effect of BFI scores.
```{r}
summary(glmer(entrain ~ extraversion + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ openness + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ agreeableness + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ conscientiousness + (1|speaker), d, family=binomial))
summary(glmer(entrain ~ neuroticism + (1|speaker), d, family=binomial))
```

(It doesn't make sense to analyze the direction of the effect here---snychrony vs. dyssynchrony---because there were almost no synchrony effects.)

(I also wanted to link the temperature and speech datasets to analyze them in relation to each other. But there are so few speech data points with significant entrainment, that it doesn't make sense to make this analysis.)


# Session Info

```{r}
sessionInfo()
```