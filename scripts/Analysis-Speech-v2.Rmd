---
title: "Analysis-Speech"
author: "Tom Offrede"
output:
  html_document:
    toc: true
    toc_float: 
      collapsed: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
library(tidyverse)
library(lmerTest)
library(DHARMa)
library(broom)
library(parsnip)

load(paste0(here::here(), "/data/speechData.RData"))
load(paste0(here::here(), "/data/metadata-clean.RData"))
load(paste0(here::here(), "/data/individualTemp.RData"))
meta <- m

all <- data.frame(matrix(nrow=0, ncol=8))
names(all) <- c("speaker", "type", "direction", "mock", "real", "condition", "feature", "section")
```

# Summary of results

* Some participants entrained and some didn't; sometimes only in the first part of the experiment, sometimes in the second, sometimes across it all.
* The most common effect was of dyssynchrony, meaning the participants often produce different f0 from the previous turn's last IPU. Makes sense: question-answer.
* I didn't find any effects of condition.

# Notes

* The check of residuals of logistic models below, was done following: https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html

# Local convergence
(following Levitan & Hirschberg 2011's method)

## f0 median

### Across the entire experiment

```{r}
ggplot(dat, aes(turnOverall, f0medDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0medDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMedDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "entireExp") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

Below we see the only 3 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged and two diverged on f0 median. All from the impersonal condition.

```{r}
print(count)
```


### Only in the first part of the experiment
Since we could argue that the speakers converge to each other only in the beginning, and that in the second part of the experiment the difference between f0s doesn't keep decreasing (or increasing)

```{r}
ggplot(dat |> filter(task=="Lists"), aes(turnOverall, f0medDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0medDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMedDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "Lists") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

Below we see the only 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged (in the close condition) and one diverged (impersonal condition) on f0 median.
These 2 are different from the 3 displayed above.

```{r}
print(count)
```


### Only in the second part of the experiment
Since we could argue that the speakers converge to each other more in the second part of the experiment, after they already got to know each other (and like each other or not) in the first part.

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(turnOverall, f0medDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0medDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMedDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "Diapix") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

Below we see the only speaker whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

She was in the close condition and converged to her partner.

```{r}
print(count)
```


## f0 max

### Across the entire experiment

```{r}
ggplot(dat, aes(turnOverall, f0maxDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0maxDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMaxDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "entireExp") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

No one seemed to converge or diverge on f0 max.

```{r}
print(count)
```


### Only in the first part of the experiment
Since we could argue that the speakers converge to each other only in the beginning, and that in the second part of the experiment the difference between f0s doesn't keep decreasing (or increasing)

```{r}
ggplot(dat |> filter(task=="Lists"), aes(turnOverall, f0maxDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0maxDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMaxDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "Lists") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

Below we see the only 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged (in the close condition) and one diverged (impersonal condition) on f0 max.

```{r}
print(count)
```


### Only in the second part of the experiment
Since we could argue that the speakers converge to each other more in the second part of the experiment, after they already got to know each other (and like each other or not) in the first part.

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(turnOverall, f0maxDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0maxDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMaxDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "Diapix") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

Below we see the only 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One diverged and one converged on f0 max. Both were in the impersonal condition.

```{r}
print(count)
```

## f0 SD

### Across the entire experiment

```{r}
ggplot(dat, aes(turnOverall, f0sdDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0sdDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSdDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "entireExp") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

No one seemed to converge or diverge on f0 sd.

```{r}
print(count)
```


### Only in the first part of the experiment
Since we could argue that the speakers converge to each other only in the beginning, and that in the second part of the experiment the difference between f0s doesn't keep decreasing (or increasing)

```{r}
ggplot(dat |> filter(task=="Lists"), aes(turnOverall, f0sdDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0sdDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSdDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "Lists") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

Below we see the only 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged (in the impersonal condition) and one diverged (close condition) on f0 sd.

```{r}
print(count)
```


### Only in the second part of the experiment
Since we could argue that the speakers converge to each other more in the second part of the experiment, after they already got to know each other (and like each other or not) in the first part.

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(turnOverall, f0sdDiff))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0sdDiff, d$turnOverall,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSdDiff", i)], d$turnOverall,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "convergence",
           r > 0 ~ "divergence"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "convergence",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "Diapix") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

Below we see the only 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged (in the impersonal condition) and one diverged (close condition) on f0 sd.

```{r}
print(count)
```

# Local Synchrony

## f0 median

### Across the entire experiment

```{r}
ggplot(dat, aes(f0med, prevf0med))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0med, d$prevf0med,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMed", i)], d$f0med,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "entireExp") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

Below we see the 4 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One converged (impersonal condition) and three diverged (2 in impersonal and 1 in close condition.)

```{r}
print(count)
```

### Only in the first part of the experiment

```{r}
ggplot(dat |> filter(task=="Lists"), aes(f0med, prevf0med))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0med, d$prevf0med,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMed", i)], d$f0med,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "Lists") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

Below we see the 4 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One in the close condition synchronized and two in the close condition desynchronized. One in the impersonal condition desynchronized.

```{r}
print(count)
```

### Only in the second part of the experiment

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(f0med, prevf0med))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0med, d$prevf0med,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMed", i)], d$f0med,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0median",
         section = "Diapix") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

Below we see the 3 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

All three desynchronized. One in the close condition and two in the impersonal condition.

```{r}
print(count)
```

## f0 max

### Across the entire experiment

```{r}
ggplot(dat, aes(f0max, prevf0max))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0max, d$prevf0max,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMax", i)], d$f0max,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "entireExp") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

Below we see the 8 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

All desynchronized. Two in the close condition and six in the impersonal condition.

```{r}
print(count)
```

### Only in the first part of the experiment

```{r}
ggplot(dat |> filter(task=="Lists"), aes(f0max, prevf0max))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0max, d$prevf0max,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMax", i)], d$f0max,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "Lists") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

Below we see the only speaker whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

She was in the impersonal condition and desynchronized.

```{r}
print(count)
```

### Only in the second part of the experiment

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(f0max, prevf0max))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0max, d$prevf0max,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockMax", i)], d$f0max,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0max",
         section = "Diapix") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

Below we see the 3 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

All desynchronized, one in the close and two in the impersonal condition.

```{r}
print(count)
```

## f0 SD

### Across the entire experiment

```{r}
ggplot(dat, aes(f0sd, prevf0sd))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s)
  c <- cor.test(d$f0sd, d$prevf0sd,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSd", i)], d$f0sd,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "entireExp") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

Below we see the 5 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

One synchronized (close condition). Four desynchronized (two close and two impersonal condition).

```{r}
print(count)
```

### Only in the first part of the experiment

```{r}
ggplot(dat |> filter(task=="Lists"), aes(f0sd, prevf0sd))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Lists")
  c <- cor.test(d$f0sd, d$prevf0sd,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSd", i)], d$f0sd,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "Lists") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

Below we see the 2 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

Both desynchronized and were in the close condition.

```{r}
print(count)
```

### Only in the second part of the experiment

```{r}
ggplot(dat |> filter(task=="Diapix"), aes(f0sd, prevf0sd))+
  geom_point()+
  geom_smooth(method="lm")+
  facet_wrap(~speaker)
```

```{r}
corS <- data.frame(matrix(nrow=0, ncol=4))
names(corS) <- c("speaker", "type", "r", "p")

for(s in unique(dat$speaker)){
  d <- dat |> filter(speaker==s, task=="Diapix")
  if(nrow(d) ==0){next} # because we don't have the Diapix files for one dyad
  
  c <- cor.test(d$f0sd, d$prevf0sd,
                alternative="two.sided", method="pearson")
  corS[nrow(corS)+1,] <- c(s, "real", c$estimate, c$p.value)
  
  for(i in 1:10){
    c <- cor.test(d[,paste0("mockSd", i)], d$f0sd,
                  alternative="two.sided", method="pearson")
    corS[nrow(corS)+1,] <- c(s, "mock", c$estimate, c$p.value)
  }
}

corS <- corS |> 
  mutate(sign = ifelse(p < 0.05, "*", NA),
         direction = case_when(
           r < 0 ~ "synchrony",
           r > 0 ~ "dyssynchrony"))

count <- data.frame(matrix(nrow=0, ncol=5))
names(count) <- c("speaker", "type", "direction", "mock", "real")

for(s in unique(corS$speaker)){
  count[nrow(count)+1,] <- c(s,
                             "synchrony",
                             corS$direction[corS$speaker==s & corS$type=="real"],
                             sum(!is.na(corS$sign[corS$speaker==s & corS$type=="mock"])==TRUE),
                             ifelse(corS$sign[corS$speaker==s & corS$type=="real"]=="*", "yes", "no"))
}

count <- merge(count, dat |> select(condition, speaker) |> filter(!duplicated(speaker)), by ="speaker")

count <- count |>
  mutate_at("mock", as.numeric) |> 
  arrange(mock) |> 
  mutate(feature = "f0sd",
         section = "Diapix") |> 
  filter(mock <= 1, real=="yes")

all <- rbind(all, count)
```

Below we see the 4 speakers whose correlation was significant between time and real f0 median differences AND who had no more than 1 significant correlation between time and randomly ordered f0 median.

All desynchronized -- two in the close and two in the impersonal condition.

```{r}
print(count)
```

# All effects

```{r}
all <- all |> 
  mutate(sectionN = case_when(
    section=="entireExp" ~ 1,
    section=="Lists" ~ 2,
    section=="Diapix" ~ 3
    )) |> 
  arrange(sectionN) |> 
  select(-sectionN)
print(all)
```

Most effects were when we take the entire experiment. But a considerable number of effects in each section too.
(Note: the higher number of effects across the whole experiment should *not* be because of the increased number of datapoints, since we do a robustness check with 10 pseudo-datapoints to control for number of points.)
```{r}
table(all$section)
table(paste(all$section, all$type))
```

There is a similar number of divergence and convergence effects. But there was almost no synchrony and a lot of dyssynchrony.
```{r}
table(all$direction)
```

There was roughly the same number of effects on each feature.
```{r}
table(all$feature)
table(paste(all$feature, all$direction[all$direction!="dyssynchrony"]))
```

When a given speaker shows an effect, they more likely also show other effects. But most often, each speaker showed only 2 effects. Some speakers also only showed 1 effect.
```{r}
sort(table(all$speaker))
hist(table(all$speaker))
```

# Exploring relationships between effects above and questionnaire scores

## Convergence

```{r}
d <- all |> 
  filter(type == "convergence") |> 
  select(-condition)
d <- merge(d, meta, by="speaker", all=TRUE) |> 
  mutate(real = ifelse(is.na(real), "no", real),
         direction = ifelse(is.na(direction), "no", direction),
         type = ifelse(is.na(type), "convergence", type)) |> 
  mutate_at(c("real", "direction", "type"), as.factor)
d$direction <- relevel(d$direction, ref="no")
```

Condition: no effect
```{r}
summary(glmer(real ~ condition + (1|speaker), d, family=binomial))
```

Scores on questionnaire about perception of partner: no effect
```{r}
summary(glmer(real ~ closeness + (1|speaker), d, family=binomial))
summary(glmer(real ~ similarity + (1|speaker), d, family=binomial))
summary(glmer(real ~ likeability + (1|speaker), d, family=binomial))
summary(glmer(real ~ becomeFriends + (1|speaker), d, family=binomial))
```

BFI scores: no effect, BUT openness, agreeableness, neuroticism not converging.
```{r}
summary(glmer(real ~ extraversion + (1|speaker), d, family=binomial))
summary(glmer(real ~ openness + (1|speaker), d, family=binomial))
summary(glmer(real ~ agreeableness + (1|speaker), d, family=binomial))
summary(glmer(real ~ conscientiousness + (1|speaker), d, family=binomial))
summary(glmer(real ~ neuroticism + (1|speaker), d, family=binomial))
```

### Direction of the effect (convergence vs divergence)

Condition: no effect
```{r}
m <- multinom_reg() |> 
  fit(direction ~ condition, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)
```

Questionnaire scores: no effects
```{r}
m <- multinom_reg() |> 
  fit(direction ~ closeness, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)

m <- multinom_reg() |> 
  fit(direction ~ similarity, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)

m <- multinom_reg() |> 
  fit(direction ~ likeability, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)

m <- multinom_reg() |> 
  fit(direction ~ becomeFriends, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)
```

BFI scores: no effects
```{r}
m <- multinom_reg() |> 
  fit(direction ~ extraversion, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)

m <- multinom_reg() |> 
  fit(direction ~ openness, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)

m <- multinom_reg() |> 
  fit(direction ~ agreeableness, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)

m <- multinom_reg() |> 
  fit(direction ~ conscientiousness, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)

m <- multinom_reg() |> 
  fit(direction ~ neuroticism, data=d)
tidy(m, exponentiate=TRUE, conf.int=TRUE)
```

## Synchrony

```{r}
d <- all |> 
  filter(type == "synchrony") |> 
  select(-condition)
d <- merge(d, meta, by="speaker", all=TRUE) |> 
  mutate(real = ifelse(is.na(real), "no", real),
         direction = ifelse(is.na(direction), "no", direction),
         type = ifelse(is.na(type), "synchrony", type)) |> 
  mutate_at(c("real", "direction", "type"), as.factor) 
```


Condition: the modle indicates more (dys)synchrony in impersonal condition, but if we look at the numbers and the graph that's not true.
```{r}
summary(m <- glmer(real ~ condition + (1|speaker), d, family=binomial))

# check residuals of the model that showed an effect
simulateResiduals(m, plot = T)

# but it's just not true
ggplot(d, aes(condition))+
  geom_bar()
```

Scores on questionnaire about perception of partner:
* potentially more (dys)synchrony when participants rate higher on closeness, but the residuals indicate it's not a good model

(model with similarity didn't converge)
```{r}
summary(m <- glmer(real ~ closeness + (1|speaker), d, family=binomial))
summary(glmer(real ~ similarity + (1|speaker), d, family=binomial))
summary(glmer(real ~ likeability + (1|speaker), d, family=binomial))
summary(glmer(real ~ becomeFriends + (1|speaker), d, family=binomial))

# check residuals of the model that showed an effect
simulationOutput <- simulateResiduals(m, plot = T)
```

BFI scores:
* potentially more (dys)synchrony when participants rate lower on extraversion, but the residuals indicate it's not a good model
```{r}
summary(m <- glmer(real ~ extraversion + (1|speaker), d, family=binomial))
summary(glmer(real ~ openness + (1|speaker), d, family=binomial))
summary(glmer(real ~ agreeableness + (1|speaker), d, family=binomial))
summary(glmer(real ~ conscientiousness + (1|speaker), d, family=binomial))
summary(glmer(real ~ neuroticism + (1|speaker), d, family=binomial))

# check residuals of the model that showed an effect
simulationOutput <- simulateResiduals(m, plot = T)
```

(It doesn't make sense to analyze the direction of the effect here---snychrony vs. dyssynchrony---because there were almost no synchrony effects.)

(I also wanted to link the temperature and speech datasets to analyze them in relation to each other. But there are so few speech data points with significant entrainment, that it doesn't make sense to make this analysis.)


# Session Info

```{r}
sessionInfo()
```